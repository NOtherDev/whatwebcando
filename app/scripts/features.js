(function (global) {
  'use strict';

  let Feature = global.WWCD.Feature || require('./feature').WWCD.Feature;

  let features = {
    localNotifications: new Feature({
      id: 'local-notifications',
      name: 'Local Notifications',
      description: [
        `Notifications, available through the <b>Notifications API</b>, allow authorized Web applications to draw users attention
         in a bold but standardized fashion. Notifications are generated by the Web application running in a browsers' tab to be presented
         to the user outside of the browser tab area.`,
        `Specification-wise, there are two distinct kinds of notifications in the Web - persistent and non-persistent. Persistent notifications
         are deliverable and possible to interact with also when the Web application that generated it is no longer active (i.e. the tab was closed)
         while non-persistent notifications require the tab to be active. Implementation-wise, persistent notifications require active Service Worker
         registration (but it should not be confused with <a href="/push-notifications.html">Push Messages</a> that also go through the Service
         Worker, but are triggered from the outside of the application).`
      ],
      api: `<dl>
        <dt><code>Notification.requestPermission([callback])</code></dt>
        <dd>Asks a user for the permission to show Notifications. Returns a <code>Promise</code> with the prompt result. As a legacy, it also calls <code>callback</code> function, if provided.</dd>
        <dt><code>Notification.permission</code></dt>
        <dd>Returns current permission state - <code>default</code> (user not yet decided), <code>granted</code> or <code>denied</code>.</dd>
        <dt><code>new Notification(title, [options])</code></dt>
        <dd>Displays local <b>non-persistent</b> notification outside of the browser tab area.</dd>
        <dt><code>navigator.serviceWorker.getRegistration()</code><br>
        <code>&nbsp;&nbsp;.then(reg => reg.showNotification(title, [options])</code></dt>
        <dd>Displays local <b>persistent</b> notification outside of the browser tab area.</dd>
      </dl>`,
      caniuse: 'notifications',
      tests: [
        Feature.rawTest('window', `Notification`, () => {
          try {
            if (!('Notification' in window)) {
              return false;
            }
            if ('silent' in Notification.prototype) {
              new Notification('test', {silent: true, vibrate: 100});
            }
            return true;
          } catch (e) {
            return e.message.indexOf('Silent') !== -1;
          }
        }),
        Feature.serviceWorkerRegistrationContains('showNotification')
      ],
      demo: {
        html: `<p>Current permission status is <b id="status">unavailable</b>.</p>

<p><button class="btn btn-default" onclick="requestPermission()">Request permission</button></p>
<p><button class="btn btn-default" onclick="nonPersistentNotification()">Non-persistent notification</button></p>
<p><button class="btn btn-default" onclick="persistentNotification()">Persistent notification</button></p>`,
        js: `var $status = document.getElementById('status');

if ('Notification' in window) {
  $status.innerText = Notification.permission;
}

function requestPermission() {
  if (!('Notification' in window)) {
    alert('Notification API not supported!');
    return;
  }
  
  Notification.requestPermission(function (result) {
    $status.innerText = result;
  });
}

function nonPersistentNotification() {
  if (!('Notification' in window)) {
    alert('Notification API not supported!');
    return;
  }
  
  try {
    var notification = new Notification("Hi there - non-persistent!");
  } catch (err) {
    alert('Notification API error: ' + err);
  }
}

function persistentNotification() {
  if (!('Notification' in window) || !('ServiceWorkerRegistration' in window)) {
    alert('Persistent Notification API not supported!');
    return;
  }
  
  try {
    navigator.serviceWorker.getRegistration()
      .then(reg => reg.showNotification("Hi there - persistent!"))
      .catch(err => alert('Service Worker registration error: ' + err));
  } catch (err) {
    alert('Notification API error: ' + err);
  }
}`
      },
      links: [
        {url: 'https://notifications.spec.whatwg.org/', title: 'Specification'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API', title: 'MDN: Notifications API'},
        {url: 'http://www.sitepoint.com/introduction-web-notifications-api/', title: 'SitePoint: An Introduction to the Web Notifications API'},
        {
          url: 'https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/BygptYClroM',
          title: 'PSA: Android is *only* shipping Service Worker-based Notifications'
        },
        {url: 'http://ukot.github.io/ie_web_notifications/', title: 'IE Web Notifications plugin'}
      ]
    }),

    pushNotifications: new Feature({
      id: 'push-notifications',
      name: 'Push Messages',
      description: [
        `Push Messaging is the well-known re-engagement mechanism from the mobile platforms. It
         allows the authorized Web applications to subscribe the user for the remotely sent messages that can trigger displaying a notification
         to the subscriber even if the Web application is not currently focused or even opened in the browser. The message can convey encrypted
         payload and can request displaying custom action buttons.`,
        `The Web Platform standard for Push Messages, <b>Push API</b>, utilizes the powerful concept of <b><a href="/offline.html">Service
         Workers</a></b>, code units installable by the Web app that execute separately from the app itself. Push API also requires HTTPS installation.`,
        `There is also a non-standard <a href="https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NotificationProgrammingGuideForWebsites/PushNotifications/PushNotifications.html#//apple_ref/doc/uid/TP40013225-CH3-SW1" target="_blank">proprietary
         solution available for OS X in Safari</a>, based on Apple's own notification service, with the workflow similar to standard Push API, available via
          <code>window.safari.pushNotification</code> interface.`
      ],
      api: `<dl>
        <dt><code>serviceWorkerRegistration.pushManager.subscribe()</code></dt>
        <dd>Subscribes a user for the remote Push Messages. Returns a <code>Promise</code>.</dd>
        <dt><code>serviceWorkerRegistration.pushManager.getSubscription()</code></dt>
        <dd>Returns a <code>Promise</code> indicating current Push Messages subscription state.</dd>
        <dt><code>serviceWorker.addEventListener('push', listener)</code></dt>
        <dd>An event fired when remote push message has been received, available within Service Worker instance.</dd>
      </dl>`,
      caniuse: 'push-api',
      tests: [
        Feature.windowContains('PushManager'),
        Feature.containedIn('window.safari', global.safari, 'pushNotification', false)
      ],
      links: [
        {url: 'https://w3c.github.io/push-api/', title: 'Specification Draft'},
        {
          url: 'https://developers.google.com/web/updates/2015/03/push-notificatons-on-the-open-web',
          title: 'Push Notifications on the Open Web - Chrome tutorial'
        },
        {url: 'https://hacks.mozilla.org/2015/10/keep-pushing-it-with-the-w3c-push-api/', title: 'Keep pushing it, with the W3C Push API'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/Push_API/Using_the_Push_API', title: 'MDN: Using the Push API'},
        {url: 'https://goroost.com/try-chrome-push-notifications', title: 'Chrome Push Notifications demo'},
        {url: 'https://developers.google.com/web/updates/2016/01/notification-actions', title: 'Google Developers: Notification Actions in Chrome 48'},
        {url: 'https://developers.google.com/web/updates/2016/03/web-push-encryption', title: 'Google Developers: Web Push Payload Encryption'}
      ]
    }),

    offline: new Feature({
      id: 'offline',
      name: 'Offline Mode',
      description: [`Web applications can provide the offline experience using two techniques. The older implementation,
        <b>Application Cache</b>, is <a href="http://caniuse.com/#feat=offline-apps" target="_blank">widely implemented</a> in the browsers,
        but is now in the process of deprecation due to <a href="http://alistapart.com/article/application-cache-is-a-douchebag" target="_blank">various
        conceptual and design flaws</a>. It is not covered here.`,
        `The modern alternative is called <b>Service Worker</b>. Web applications running on HTTPS can request the browser to install the separate
        code unit called Service Worker. This unit is then run in separation from the owning Web application, communicating with it via events.
        Besides being the enabler for multiple complex APIs like <a href="/push-notifications.html">Push Notifications</a>, <a href="/background-sync.html">Background Sync</a>
        or <a href="/geofencing.html">Geofencing</a>, it can work as a fully featured network proxy. It can intercept all the HTTP requests, alter its content or behaviors,
        or - most notably - manage offline caching.`,
        `<small>Code examples adapted from <a href="http://www.html5rocks.com/en/tutorials/service-worker/introduction/" target="_blank">HTML5 Rocks article</a>.</small>`],
      api: `<p><b>Within the owning Web application - Installation</b></p>
        <dl>
          <dt><code>navigator.serviceWorker.register(path)</code></dt>
          <dd>Installs the Service Worker code available under <code>path</code>. Returns a <code>Promise</code>.</dd>
          <dt><code>navigator.serviceWorker.ready</code></dt>
          <dd>Returns a <code>Promise</code> resolved with <code>serviceWorkerRegistration</code> when the Worker is initialized.</dd>
          <dt><code>serviceWorkerRegistration.update()</code></dt>
          <dd>Checks the server for an updated version of the Service Worker without consulting caches.</dd>
          <dt><code>serviceWorkerRegistration.unregister()</code></dt>
          <dd>Uninstalls the Service Worker.</dd>
        </dl>
        <p><b>Within the Service Worker instance - Cache prefetch</b></p>
        <pre><code>self.addEventListener('install', function (event) {
  event.waitUntil(
    caches.open('my-cache-v1')
      .then(function (cache) {
        return cache.addAll(['/', '/styles/main.css', '/scripts/main.js']);
      })
  );
});</code></pre>
        <dl>
          <dt><code>self.addEventListener('install', listener)</code></dt>
          <dd>An event fired within the Service Worker when it is being installed. Useful to prefetch the resources needed in the offline mode and to prefill the cache.</dd>
          <dt><code>event.waitUntil(promise)</code></dt>
          <dd>An install event method that expects a <code>Promise</code> which signals the end of the worker's installation phase when resolved.</dd>
          <dt><code>caches.open(cacheName)</code></dt>
          <dd>Returns a <code>Promise</code> resolved with the named cache accessor object that is able to keep the resources needed for the offline mode.</dd>
          <dt><code>cache.addAll(urls)</code></dt>
          <dd>Adds all the resources specified with the URLs to the named cache for the future, possibly offline, use.</dd>
        </dl>
        <p><b>Within the Service Worker instance - Requests cache</b></p>
        <pre><code>function isSuccessful(response) {
  return response &&
    response.status === 200 &&
    response.type === 'basic';
}

self.addEventListener('fetch', function (event) {
  event.respondWith(
    caches.match(event.request)
      .then(function (response) {
        if (response) {
          return response; // Cache hit
        }

        return fetch(event.request.clone())
          .then(function (response) {
            if (!isSuccessful(response)) {
              return response;
            }

            caches.open(CACHE_NAME)
              .then(function (cache) {
                cache.put(event.request, response.clone());
              });

            return response;
          }
        );
      })
    );
});</code></pre>
        <dl>
          <dt><code>self.addEventListener('fetch', listener)</code></dt>
          <dd>An event fired within the Service Worker whenever any of its related browser tabs have issued a HTTP request. Useful to serve already cached response
            or intercept and cache the incoming response.</dd>
          <dt><code>event.respondWith(promise)</code></dt>
          <dd>A fetch event method that expects a <code>Promise</code> which resolves with the request data to be returned to the requesting browser tab.</dd>
          <dt><code>cache.put(request, response)</code></dt>
          <dd>Adds the specified response for the request to the named cache for the future, possibly offline, use.</dd>
          <dt><code>caches.match(event.request)</code></dt>
          <dd>Returns a <code>Promise</code> resolved when the <code>fetch</code> event represents a request to the resource already cached within
            the Service Worker's cache.</dd>
      </dl>
      <p>See also <b><a href="sw.js" target="_blank">this website's own Service Worker implementation</a></b>.</p>`,
      caniuse: 'serviceworkers',
      tests: [Feature.navigatorContains('serviceWorker')],
      links: [
        {url: 'http://www.w3.org/TR/service-workers/', title: 'Service Workers Specification Draft'},
        {url: 'http://www.html5rocks.com/en/tutorials/service-worker/introduction/', title: 'HTML5 Rocks: Introduction to Service Worker'},
        {url: 'https://jakearchibald.com/2014/offline-cookbook/', title: 'The offline cookbook'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker_API', title: 'ServiceWorker API - MDN docs'},
        {
          url: 'https://googlechrome.github.io/samples/service-worker/prefetch/index.html',
          title: 'Service Worker Sample: Pre-fetching Resources During Registration'
        },
        {
          url: 'https://medium.com/@slsoftworks/beyond-offline-bf5c013ec8e7',
          title: 'Beyond Offline: Using a custom service worker to expand on your browser’s capabilities'
        },
        {url: 'https://ponyfoo.com/articles/serviceworker-revolution', title: 'ServiceWorker: Revolution of the Web Platform'},
        {url: 'https://jakearchibald.github.io/isserviceworkerready/resources.html', title: 'Is ServiceWorker Ready? - Jake Archibald'},
        {url: 'https://css-tricks.com/serviceworker-for-offline/', title: 'Making a Simple Site Work Offline with ServiceWorker'}
      ]
    }),

    manifest: new Feature({
      id: 'installation',
      name: 'Home Screen Installation',
      description: [`Web applications can provide the <code>manifest.json</code> file, standarized as the <b>Web Manifest</b>, specifying the features
       and behaviors needed on order to treat the application as a first-class citizen on the mobile platform, i.e. adding ("installing") to the home screen
       with the relevant icon, full screen behaviors, themes, standalone appearance without browser bar etc. It can also serve as a centralized place
       to put all the metadata associated with the Web application.`,
        `Having the Web Manifest is one of the key factors (apart from being served via HTTPS and providing
       a <a href="/offline.html">Service Worker-based offline behavior</a>) for the Web applications to be treated
       as a <a href="https://developers.google.com/web/progressive-web-apps" target="_blank">Progressive Web App</a>. Such applications
       get non-obtrusive "add to home screen" banners in most Android browsers.`,
        `Browser-assisted adding to the home screen is also possible on iOS using <a href="https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html" target="_blank">non-standard Apple meta tags</a>
       describing icons and allowing to run without the Safari UI (standalone mode).`],
      api: `<p><b>Manifest Elements</b></p>
<pre><code>{
  "short_name": "Example App",
  "name": "The Example Application",
  "icons": [
    {
      "src": "launcher-icon-1x.png",
      "sizes": "48x48"
    },
    {
      "src": "launcher-icon-2x.png",
      "sizes": "96x96"
    }
  ],
  "theme_color": "#ff0000",
  "background_color": "#ff0000",
  "start_url": "index.html",
  "display": "standalone"
}</code></pre>
<p>See also <b><a href="manifest.json" target="_blank">this website's own manifest.json</a></b>.</p>
<p><b>Install Banner API</b></p>
<dl>
  <dt><code>window.addEventListener('beforeinstallprompt')</code></dt>
  <dd>An event fired when the browser's heuristic decides to display the "add to home screen" banner to the user. Allows tracking the user's decision and presenting the banner from the custom UI.</dd>
  <dt><code>event.prompt()</code></dt>
  <dd>Triggers displaying the "add to home screen" banner from the custom UI.</dd>
  <dt><code>event.userChoice</code></dt>
  <dd>Returns <code>Promise</code> resolved with the outcome of the "add to home screen" banner – either <code>accepted</code> or <code>dismissed</code>.</dd>
  <dt><code>window.addEventListener('appinstalled')</code></dt>
  <dd>An event fired when the Web application has been successfully added to the user's home screen.</dd>
</dl>`,
      caniuse: 'web-app-manifest',
      tests: [
        Feature.windowContains('BeforeInstallPromptEvent')
      ],
      links: [
        {url: 'https://w3c.github.io/manifest/', title: 'Specification Draft'},
        {
          url: 'https://developers.google.com/web/updates/2014/11/Support-for-installable-web-apps-with-webapp-manifest-in-chrome-38-for-Android?hl=en',
          title: 'Installable Web Apps with the WebApp Manifest in Chrome for Android'
        },
        {url: 'http://html5doctor.com/web-manifest-specification/', title: 'HTML5 Doctor: The Web Manifest specification'},
        {url: 'http://brucelawson.github.io/manifest/', title: 'Manifest Generator by Bruce Lawson'},
        {url: 'https://pwa.rocks/', title: 'A selection of Progressive Web Apps'},
        {
          url: 'https://developers.google.com/web/fundamentals/engage-and-retain/app-install-banners/',
          title: 'Google Developers: Web App Install Banners'
        }
      ]
    }),

    foregroundDetection: new Feature({
      id: 'foreground-detection',
      name: 'Foreground Detection',
      description: `The <b>Page Visibility API</b> is useful for the Web application to know whether it is currently displayed on the front or not,
        especially to stop resource-intensive UI animations or data refreshing when it is not needed. On the mobile devices,
        the primary reason for that is to reduce the battery usage.`,
      api: `<dl>
        <dt><code>document.hidden</code></dt>
        <dd>Returns <code>true</code> if the page is currently hidden.</dd>
        <dt><code>document.visibilityState</code></dt>
        <dd>Returns current visibility state: <code>visible</code>, <code>hidden</code>, <code>prerender</code> or <code>unloaded</code>.</dd>
        <dt><code>document.addEventListener('visibilitychange')</code></dt>
        <dd>An event fired when the visibility state of the page has changed.</dd>
      </dl>`,
      caniuse: 'pagevisibility',
      demo: {
        html: `<p>Switch the browser tab to see the changes.</p>
<p>Initial page visibility was <b id="status">unknown</b>.</p>
<div id="target"></div>
<p><small>Based on demo from <a href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API">MDN</a>.</small></p>`,
        js: `var target = document.getElementById('target');

var hidden, visibilityChange;
if (typeof document.hidden !== "undefined") {
  hidden = "hidden";
  visibilityChange = "visibilitychange";
} else if (typeof document.mozHidden !== "undefined") {
  hidden = "mozHidden";
  visibilityChange = "mozvisibilitychange";
} else if (typeof document.msHidden !== "undefined") {
  hidden = "msHidden";
  visibilityChange = "msvisibilitychange";
} else if (typeof document.webkitHidden !== "undefined") {
  hidden = "webkitHidden";
  visibilityChange = "webkitvisibilitychange";
} else {
  target.innerText = 'Page Visibility API not supported.';
}

function handleVisibilityChange() {
  var timeBadge = new Date().toTimeString().split(' ')[0];
  var newState = document.createElement('p');
  newState.innerHTML = '<span class="badge">' + timeBadge + '</span> Page visibility changed to <b>' + (document[hidden] ? 'hidden' : 'visible') + '</b>.';
  target.appendChild(newState);
}

document.addEventListener(visibilityChange, handleVisibilityChange, false);

if (hidden in document) {
  document.getElementById('status').innerHTML = document[hidden] ? 'hidden' : 'visible';
}`,
        jsOnExit: `document.removeEventListener(visibilityChange, handleVisibilityChange);`
      },
      tests: [Feature.containedIn('document', global.document, 'visibilityState')],
      links: [
        {url: 'https://w3c.github.io/page-visibility/', title: 'Specification Draft'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API', title: 'MDN: Page Visibility API'},
        {url: 'http://www.sitepoint.com/introduction-to-page-visibility-api/', title: 'SitePoint: Introduction to Page Visibility API'}
      ]
    }),

    geolocation: new Feature({
      id: 'geolocation',
      name: 'Geolocation',
      description: [`The <b>Geolocation API</b> lets authorized Web applications to access the location data provided by the device -
        obtained using either GPS or from the network environment. Apart from the one-off location query, it gives a way for the app to be notified
        about the location changes.`,
        `See <a href="/permissions.html">Permissions</a> for a way to check whether the user has granted or denied the permission to obtain the location by the origin.`],
      api: `<dl>
        <dt><code>navigator.geolocation.getCurrentPosition(callback)</code></dt>
        <dd>Runs one-off query for location with coordinates, accuracy, altitude & speed, if available.</dd>
        <dt><code>navigator.geolocation.watchPosition(callback)</code></dt>
        <dd>Sets up observing for location changes, invoking callback for every change.</dd>
      </dl>`,
      caniuse: 'geolocation',
      demo: {
        html: `<button class="btn btn-default" id="askButton">Ask for location</button>

<div id="target"></div>`,
        js: `var target = document.getElementById('target');
var watchId;

function appendLocation(location, verb) {
  verb = verb || 'updated';
  var newLocation = document.createElement('p');
  newLocation.innerHTML = 'Location ' + verb + ': <a href="https://maps.google.com/maps?&z=15&q=' + location.coords.latitude + '+' + location.coords.longitude + '&ll=' + location.coords.latitude + '+' + location.coords.longitude + '" target="_blank">' + location.coords.latitude + ', ' + location.coords.longitude + '</a>';
  target.appendChild(newLocation);
}

if ('geolocation' in navigator) {
  document.getElementById('askButton').addEventListener('click', function () {
    navigator.geolocation.getCurrentPosition(function (location) {
      appendLocation(location, 'fetched');
    });
    watchId = navigator.geolocation.watchPosition(appendLocation);
  });
} else {
  target.innerText = 'Geolocation API not supported.';
}`,
        jsOnExit: `if (watchId) navigator.geolocation.clearWatch(watchId)`
      },
      tests: [Feature.navigatorContains('geolocation')],
      links: [
        {url: 'http://www.w3.org/TR/geolocation-API/', title: 'Specification'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation', title: 'MDN: Using geolocation'}
      ]
    }),

    bluetooth: new Feature({
      id: 'bluetooth',
      name: 'Bluetooth',
      description: [
        `The <b>Web Bluetooth API</b> is a low-level API allowing Web applications to access the services exposed by nearby Bluetooth-enabled devices.`
      ],
      api: `<dl>
        <dt><code>navigator.bluetooth.requestDevice(serviceFilters)</code></dt>
        <dd>Scans for the device in range supporting the requested services. Returns a <code>Promise</code>.</dd>
        <dt><code>device.gatt.connect()</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the server object providing access to the services available on the device.</dd>
        <dt><code>server.getPrimaryService(name)</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the particular Bluetooth service on the device.</dd>
        <dt><code>service.getCharacteristic(name)</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the GATT characteristic object.</dd>
        <dt><code>characteristic.readValue()</code></dt>
        <dd>Returns a <code>Promise</code> resolved with a raw value from the GATT characteristic.</dd>
        <dt><code>characteristic.writeValue(value)</code></dt>
        <dd>Writes a new value for the GATT characteristic.</dd>
      </dl>`,
      tests: [Feature.navigatorContains('bluetooth')],
      caniuse: 'web-bluetooth',
      demo: {
        html: `<p>
  <button class="btn btn-lg btn-default" onclick="readBatteryLevel()">Read Bluetooth device's<br>battery level</button>
</p>

<p id="target"></p>

<p><small>Based on code snippets from <a href="https://developers.google.com/web/updates/2015/07/interact-with-ble-devices-on-the-web" target="_blank">Google Developers</a>.</small></p>`,
        js: `function readBatteryLevel() {
  var $target = document.getElementById('target');
  
  if (!('bluetooth' in navigator)) {
    $target.innerText = 'Bluetooth API not supported.';
    return;
  }
  
  navigator.bluetooth.requestDevice({
      filters: [{
        services: ['battery_service']
      }]
    })
    .then(function (device) {
      return device.gatt.connect();
    })
    .then(function (server) {
      return server.getPrimaryService('battery_service');
    })
    .then(function (service) {
      return service.getCharacteristic('battery_level');
    })
    .then(function (characteristic) {
      return characteristic.readValue();
    })
    .then(function (value) {
      $target.innerHTML = 'Battery percentage is <b>' + value.getUint8(0) + '</b>.';
    })
    .catch(function (error) {
      $target.innerText = error;
    });
}`
      },
      links: [
        {url: 'https://webbluetoothcg.github.io/web-bluetooth/', title: 'Specification Draft'},
        {url: 'https://developers.google.com/web/updates/2015/07/interact-with-ble-devices-on-the-web', title: 'Interact with BLE devices on the Web'}
      ]
    }),

    nfc: new Feature({
      id: 'nfc',
      name: 'NFC',
      description: [
        `The <b>Web NFC API</b> is a low-level API that provides sites the ability to read and write to nearby NFC (Near-Field Communication) devices.`,
        `It allows starting up a scan that informs when an NFC tag matching some <code>options</code> has been tapped. It also provides a method to push a message via NFC.`,
        `Current support is limited to an experimental implementation in Chrome, available behind the "enable-webnfc" flag on Android. There was also Firefox OS experimental implementation that is <code>moz</code>-prefixed and doesn't follow the current state of the specification draft.`
      ],
      api: `<dl>
        <dt><code>const reader = new NDEFReader()</code></dt>
        <dd>Creates an object used for NDEF readings.</dd>
        <dt><code>reader.start(options)</code></dt>
        <dd>Returns a <code>Promise</code> resolved if starting NFC scan was successful.</dd>
        <dt><code>reader.addEventListener('reading', listener)</code></dt>
        <dd>An event fired when a new reading is available.</dd>
        <dt><code>reader.addEventListener('error', listener)</code></dt>
        <dd>An event fired when an error happened during reading.</dd>
        <dt><code>const writer = new NDEFWriter()</code></dt>
        <dd>Creates an object used for NDEF writings.</dd>
        <dt><code>writer.push(message, options)</code></dt>
        <dd>Returns a <code>Promise</code> resolved if pushing the <code>message</code> (String, ArrayBuffer or NDEF record) with <code>options</code> was successful.</dd>
      </dl>`,
      tests: [
        Feature.windowContains('NDEFReader'),
        Feature.windowContains('NDEFWriter')
      ],
      demo: {
        html: `<p>
  <button class="btn btn-lg btn-default" onclick="readTag()">Test NFC Read</button>
  <button class="btn btn-lg btn-default" onclick="writeTag()">Test NFC Write</button>
</p>

<pre id="log"></pre>

<p><small>Based on the code snippets from <a href="https://w3c.github.io/web-nfc/#examples">specification draft</a>.</small></p>`,
        js: `async function readTag() {
  if ("NDEFReader" in window) {
    const reader = new NDEFReader();
    try {
      await reader.scan();
      reader.onreading = event => {
        const decoder = new TextDecoder();
        for (const record of event.message.records) {
          consoleLog("Record type:  " + record.recordType);
          consoleLog("MIME type:    " + record.mediaType);
          consoleLog("=== data ===\\n" + decoder.decode(record.data));
        }
      }
    } catch(error) {
      consoleLog(error);
    }
  } else {
    consoleLog("Web NFC is not supported.");
  }
}

async function writeTag() {
  if ("NDEFWriter" in window) {
    const writer = new NDEFWriter();
    try {
      await writer.push("What Web Can Do Today");
      consoleLog("NDEF message pushed!");
    } catch(error) {
      consoleLog(error);
    }
  } else {
    consoleLog("Web NFC is not supported.");
  }
}

function consoleLog(data) {
  var logElement = document.getElementById('log');
  logElement.innerHTML += data + '\\n';
};`
      },
      links: [
        {url: 'https://w3c.github.io/web-nfc/', title: 'Specification Draft'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/NFC_API/Using_the_NFC_API', title: 'MDN: Using the NFC API (covers outdated spec revision)'}
      ]
    }),

    proximity: new Feature({
      id: 'proximity',
      name: 'Proximity Sensors',
      description: [`The <b>Proximity Events API</b> allows Web applications to get the access to the data from the device's proximity sensors, detecting whether there is a physical object near the device.`,
        `The first approach to supporting proximity sensor on the Web - as a standalone API - was implemented in Firefox. Since then the specification was rewritten to make use of the new <b>Generic Sensors API</b>, but no vendor implemented that spec as of September 2017.`],
      api: `<p><b>The old, standalone API</b></p>
      <dl>
        <dt><code>window.addEventListener('deviceproximity', listener)</code></dt>
        <dd>An event fired when the device has sensed the physical object proximity, containing approximate distance information.</dd>
        <dt><code>window.addEventListener('userproximity', listener)</code></dt>
        <dd>An event fired when the device has roughly sensed the physical object proximity, containing boolean <code>near</code> flag only.</dd>
      </dl>
      <p><b>The new, generic API</b></p>
      <dl>
        <dt><code>sensor = new ProximitySensor()</code></dt>
        <dd>Creates an object serving as an accessor to the proximity sensor readings.</dd>
        <dt><code>sensor.addEventListener('reading', listener)</code></dt>
        <dd>An event fired when the physical object proximity reading has changed, indicating that the sensor object contains updated approximate distance information in cm (<code>sensor.distance</code>) and boolean <code>sensor.near</code> flag.</dd>
        <dt><code>sensor.start()</code></dt>
        <dd>Starts listening for the sensor readings.</dd>
      </dl>`,
      caniuse: 'proximity',
      tests: [
        Feature.windowContains('ondeviceproximity'),
        Feature.windowContains('onuserproximity'),
        Feature.windowContains('ProximitySensor')
      ],
      demo: {
        html: `<p>Current approximate distance to object is <b id="deviceValue">unknown</b>.</p>
<p>Currently, the object is <b id="nearValue">in unknown proximity</b>.</p>

<div id="box"></div>`,
        cssHidden: `#box {
  width: 100px;
  height: 100px;
  border: 1px solid #000;
  margin-left: 10px;
  background-color: gray;
  -webkit-transition: all 0.5s ease;
  -moz-transition: all 0.5s ease;
  -o-transition: all 0.5s ease;
  transition: all 0.5s ease;
}`,
        js: `var box = document.getElementById('box');

function onDeviceProximityChanged(event) {
  document.getElementById('deviceValue').innerHTML = event.value + ' cm (' + event.min + '-' + event.max + ' cm range)';
  
  var size = Math.min(200, Math.max(20, 500 / (event.value || 1)));
  
  box.style.width = size + 'px';
  box.style.height = size + 'px';
}

function onUserProximityChanged(event) {
  document.getElementById('nearValue').innerHTML = event.near ? 'near' : 'rather far';
  box.style.backgroundColor = event.near ? 'red' : 'green';
}

window.addEventListener('deviceproximity', onDeviceProximityChanged);
window.addEventListener('userproximity', onUserProximityChanged);`,
        jsOnExit: `window.removeEventListener('deviceproximity', onDeviceProximityChanged);
window.removeEventListener('userproximity', onUserProximityChanged);`
      },
      links: [
        {url: 'https://w3c.github.io/proximity/', title: 'Proximity API Specification Draft'},
        {url: 'https://w3c.github.io/sensors/', title: 'Generic Sensor API Specification Draft'},
        {url: 'http://www.sitepoint.com/introducing-proximity-api/', title: 'SitePoint: Introducing the Proximity API'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/Proximity_Events', title: 'MDN: Proximity Events'}
      ]
    }),

    ambientLight: new Feature({
      id: 'ambient-light',
      name: 'Ambient Light',
      description: [`The <b>Ambient Light API</b> allows Web applications to access the light intensity level measured by the device's light sensor, normally built-in with the device's camera.`,
        `The first approach to supporting light intensity sensor on the Web - as a standalone API - was implemented in Firefox back in 2013. Since then the specification was rewritten to make use of the new <b>Generic Sensors API</b>. This flavor, as of summer 2017, is implemented in Microsoft Edge and - behind the "Experimental Web Platform Features" flag - in Google Chrome.`],
      api: `<p><b>The old, standalone API</b></p>
      <dl>
        <dt><code>window.addEventListener('devicelight', listener)</code></dt>
        <dd>An event fired when the device's light sensor measured value has changed, containing the light intensity expressed in lux.</dd>
      </dl>
      <p><b>The new, generic API</b></p>
      <dl>
        <dt><code>sensor = new AmbientLightSensor()</code></dt>
        <dd>Creates an object serving as an accessor to the light intensity sensor readings.</dd>
        <dt><code>sensor.addEventListener('reading', listener)</code></dt>
        <dd>An event fired when the light intensity reading has changed, indicating that the sensor object contains updated light intensity expressed in lux, in <code>sensor.illuminance</code> property.</dd>
        <dt><code>sensor.start()</code></dt>
        <dd>Starts listening for the sensor readings.</dd>
      </dl>`,
      caniuse: 'ambient-light',
      tests: [
        Feature.windowContains('ondevicelight'),
        Feature.windowContains('AmbientLightSensor')
      ],
      demo: {
        html: `<p>Current light intensity is <b id="value">unknown</b>.</p>

<div id="box"></div>`,
        cssHidden: `#box {
  width: 100px;
  height: 100px;
  border: 1px solid #000;
  margin-left: 10px;
}`,
        js: `function update(illuminance) {
  document.getElementById("value").innerHTML = illuminance + " lux";

  var colorPart = Math.min(255, illuminance).toFixed(0);
  document.getElementById("box").style.backgroundColor =
    "rgb(" + colorPart + ", " + colorPart + ", " + colorPart + ")";
}

if ("AmbientLightSensor" in window) {
  try {
    var sensor = new AmbientLightSensor();
    sensor.addEventListener("reading", function (event) {
      update(sensor.illuminance);
    });
    sensor.start();
  } catch (e) {
    console.error(e);
  }
}
if ("ondevicelight" in window) {
  function onUpdateDeviceLight(event) {
    update(event.value);
  }
  
  window.addEventListener("devicelight", onUpdateDeviceLight);
}`,
        jsOnExit: `if (onUpdateDeviceLight) window.removeEventListener('devicelight', onUpdateDeviceLight);`
      },
      links: [
        {url: 'https://w3c.github.io/ambient-light/', title: 'Ambient Light API Specification Draft'},
        {url: 'https://w3c.github.io/sensors/', title: 'Generic Sensor API Specification Draft'},
        {url: 'https://deanhume.com/ambient-light-sensor/', title: 'Getting started with the Ambient Light Sensor'}
      ]
    }),

    mediaCapture: new Feature({
      id: 'camera-microphone',
      name: 'Audio & Video Capture',
      description: [`The <b>Media Capture API</b> allows authorized Web applications to access the streams from the device's audio and video capturing
        interfaces, i.e. to use the data available from the camera and the microphone. The streams exposed by the API can be bound directly to the HTML
        <code>&lt;audio&gt;</code> or <code>&lt;video&gt;</code> elements or read and manipulated in the code, including further more specific processing via <a href="/photos.html">Image Capture API</a>, <a href="/recording.html">Media Recorder API</a> or <a href="/realtime.html">Real-Time Communication</a>.`,
        `There is also a higher level alternative <a href="http://www.wufoo.com/html5/attributes/20-accept.html">built-in into mobile operating systems</a>
        like iOS and Android that doesn't require any JavaScript API - the basic HTML <code>&lt;input type="file" accept="image/*"&gt;</code> element allows
        launching any application that provides an image file, including camera.`],
      api: `<dl>
        <dt><code>navigator.mediaDevices.getUserMedia(constraints)</code></dt>
        <dd>Prompts user for an access to the media interface specified by the <code>constraints</code>
          and returns a <code>Promise</code> that is resolved with the interface's stream handler.</dd>
        <dt><code>stream.getAudioTracks()</code></dt>
        <dd>Returns a collection of audio tracks objects being provided by the device's microphone.</dd>
        <dt><code>stream.getVideoTracks()</code></dt>
        <dd>Returns a collection of video tracks objects being provided by the device's camera.</dd>
        <dt><code>mediaElement.srcObject = stream</code></dt>
        <dd>Sets a stream to be rendered into the provided <code>&lt;audio&gt;</code> or <code>&lt;video&gt;</code> DOM element.</dd>
      </dl>
      <p>Previous version of the standard, supported with vendor prefixes, contained the callback-based <code>getUserMedia</code> method directly within
      the <code>navigator</code> element:</p>
      <pre><code>navigator.webkitGetUserMedia(constraints, successCallback, errorCallback)</code></pre>`,
      caniuse: 'stream',
      tests: [
        Feature.navigatorContains('getUserMedia'),
        Feature.navigatorContains('mediaDevices')
      ],
      demo: {
        html: `<div class="container" style="margin-top: 10px">
  <div class="row">
    <div class="col-sm-6">
      <p><button type="button" class="btn btn-lg btn-default" onclick="getStream('video')">Grab video</button></p>
      
      <video controls autoplay style="height:180px; width: 240px;"></video>
    </div>
    <div class="col-sm-6">
      <p><button type="button" class="btn btn-lg btn-default" onclick="getStream('audio')">Grab audio</button></p>
      
      <audio controls autoplay></audio>
    </div>
  </div>
</div>`,
        js: `function getUserMedia(options, successCallback, failureCallback) {
  var api = navigator.getUserMedia || navigator.webkitGetUserMedia ||
    navigator.mozGetUserMedia || navigator.msGetUserMedia;
  if (api) {
    return api.bind(navigator)(options, successCallback, failureCallback);
  }
}

function getStream (type) {
  if (!navigator.getUserMedia && !navigator.webkitGetUserMedia &&
    !navigator.mozGetUserMedia && !navigator.msGetUserMedia) {
    alert('User Media API not supported.');
    return;
  }

  var constraints = {};
  constraints[type] = true;
  getUserMedia(constraints, function (stream) {
    var mediaControl = document.querySelector(type);
    
    if ('srcObject' in mediaControl) {
      mediaControl.srcObject = stream;
      mediaControl.src = (window.URL || window.webkitURL).createObjectURL(stream);
    } else if (navigator.mozGetUserMedia) {
      mediaControl.mozSrcObject = stream;
    }
  }, function (err) {
    alert('Error: ' + err);
  });
}`
      },
      links: [
        {url: 'https://w3c.github.io/mediacapture-main/', title: 'Specification Draft'},
        {url: 'http://www.html5rocks.com/en/tutorials/getusermedia/intro/', title: 'HTML5 Rocks: Capturing Audio & Video in HTML5'},
        {
          url: 'http://blogs.windows.com/msedgedev/2015/05/13/announcing-media-capture-functionality-in-microsoft-edge/',
          title: 'Announcing media capture functionality in Microsoft Edge'
        },
        {
          url: 'https://dev.opera.com/blog/webcam-orientation-preview/',
          title: 'Native Webcam Support and Orientation Events — Technology Preview from Opera'
        },
        {url: 'http://www.sitepoint.com/face-proximity-detection-with-javascript/', title: 'SitePoint: Face Proximity Detection with JavaScript'}
      ]
    }),

    networkInfo: new Feature({
      id: 'network-type-speed',
      name: 'Network Type & Speed',
      description: [`The <b>Network Information API</b> allows Web applications to read the current network type and the maximum downlink speed that are assumed
        based on the underlying connection technology used by the client. It also allows to subscribe for a notification when the network type has changed.`,
        `The newest addition (mid-2017), implemented by Chrome on Android as of September 2017, also provides an effective network type information that in turn
        is calculated using the actual network performance metrics collected by the browser, allowing the Web applications to adjust to the quality of the connection.`],
      api: `<dl>
        <dt><code>navigator.connection.type</code></dt>
        <dd>Returns the theoretical type of the current connection, based on the underlying connection technology, i.e. <code>cellular</code>, <code>wifi</code>, <code>none</code> etc.</dd>
        <dt><code>navigator.connection.effectiveType</code></dt>
        <dd>Returns the information about the quality of the current connection based on recently observed performance metrics, regardless of the underlying connection technology, i.e. <code>slow-2g</code>, <code>2g</code>, <code>3g</code>, <code>4g</code>.</dd>
        <dt><code>navigator.connection.downlinkMax</code></dt>
        <dd>Returns the theoretical maxinum downlink speed, in Mbps, for the underlying technology of the current connection.</dd>
        <dt><code>navigator.connection.addEventListener('change', listener)</code></dt>
        <dd>An event fired when the connection type has changed.</dd>
      </dl>`,
      tests: [Feature.navigatorContains('connection')],
      caniuse: 'netinfo',
      demo: {
        html: `<p>Current theoretical network type is <b id="networkType">not available</b>.</p>
<p>Current effective network type is <b id="effectiveNetworkType">not available</b>.</p>
<p>Current max downlink speed is <b id="downlinkMax">not available</b>.`,
        js: `function getConnection() {
  return navigator.connection || navigator.mozConnection ||
    navigator.webkitConnection || navigator.msConnection;
}

function updateNetworkInfo(info) {
  document.getElementById('networkType').innerHTML = info.type;
  document.getElementById('effectiveNetworkType').innerHTML = info.effectiveType;
  document.getElementById('downlinkMax').innerHTML = info.downlinkMax;
}

var info = getConnection();
if (info) {
  info.addEventListener('change', updateNetworkInfo);
  updateNetworkInfo(info);
}`,
        jsOnExit: `if (info) info.removeEventListener('change', updateNetworkInfo);`
      },
      links: [
        {url: 'https://wicg.github.io/netinfo/', title: 'Specification Draft'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/Network_Information_API', title: 'MDN: Network Information API'},
        {url: 'https://mxb.at/blog/connection-aware-components/', title: 'Connection-Aware Components'}
      ]
    }),

    online: new Feature({
      id: 'online-state',
      name: 'Online State',
      description: `Browsers expose a network connection availability information to the Web application, so that the applications may react properly, i.e.
        stop all the operations utilising the network and switch to cached data when offline condition was detected.`,
      api: `<dl>
        <dt><code>navigator.onLine</code></dt>
        <dd>Returns <code>true</code> when the browser detects network connection available, <code>false</code> otherwise.</dd>
        <dt><code>window.addEventListener('online', listener)</code></dt>
        <dd>An event fired when the browser detects network connection has become available.</dd>
        <dt><code>window.addEventListener('offline', listener)</code></dt>
        <dd>An event fired when the browser detects network connection has become unavailable.</dd>
      </dl>`,
      caniuse: 'online-status',
      tests: [Feature.navigatorContains('onLine')],
      demo: {
        html: `<p>Turn the network connection on/off to see the changes.</p>

<p>Initial connection state was <b id="status">unknown</b>.</p>

<div id="target"></div>`,
        js: `document.getElementById('status').innerHTML = navigator.onLine ? 'online' : 'offline';

var target = document.getElementById('target');

function handleStateChange() {
  var timeBadge = new Date().toTimeString().split(' ')[0];
  var newState = document.createElement('p');
  var state = navigator.onLine ? 'online' : 'offline';
  newState.innerHTML = '<span class="badge">' + timeBadge + '</span> Connection state changed to <b>' + state + '</b>.';
  target.appendChild(newState);
}

window.addEventListener('online', handleStateChange);
window.addEventListener('offline', handleStateChange);`,
        jsOnExit: `window.removeEventListener('online', handleStateChange);
window.removeEventListener('offline', handleStateChange);`
      },
      links: [
        {url: 'https://html.spec.whatwg.org/multipage/browsers.html#browser-state', title: 'Specification'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/NavigatorOnLine/onLine#Specification', title: 'MDN description'}
      ]
    }),

    vibration: new Feature({
      id: 'vibration',
      name: 'Vibration',
      description: `The <b>Vibration API</b> allows Web applications to use the device's built-in vibration, if one is present.`,
      api: `<dl>
        <dt><code>navigator.vibrate(durationOrPattern)</code></dt>
        <dd>Vibrate the device once for the duration given or according to durations pattern given.</dd>
      </dl>`,
      caniuse: 'vibration',
      tests: [Feature.navigatorContains('vibrate')],
      demo: {
        html: `<button class="btn btn-default" onclick="vibrateSimple()">Vibrate for 200 ms</button>
<button class="btn btn-default" onclick="vibratePattern()">Vibrate with pattern</button>`,
        js: `function vibrateSimple() {
  navigator.vibrate(200);
}

function vibratePattern() {
  navigator.vibrate([100, 200, 200, 200, 500]);
}`
      },
      links: [
        {url: 'http://dev.w3.org/2009/dap/vibration/', title: 'Specification Draft'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API', title: 'MDN: Vibration API'},
        {
          url: 'http://illyism.com/journal/vibrate-mobile-phone-web-vibration-api',
          title: 'Learn how to vibrate your mobile phone on the Web using the vibration API'
        }
      ]
    }),

    batteryStatus: new Feature({
      id: 'battery-status',
      name: 'Battery Status',
      description: `The <b>Battery Status API</b> allows Web applications to get the information about the device's power source, battery charge level,
        expected time of charging or discharging. It also exposes events whenever any of the information available changes. The API allows the applications
        to turn on/off its energy inefficient operations according to the power levels.`,
      api: `<dl>
        <dt><code>navigator.getBattery()</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the object containing battery information.</dd>
        <dt><code>battery.charging</code></dt>
        <dd>Returns <code>true</code> if the device is currently being charged.</dd>
        <dt><code>battery.chargingTime</code></dt>
        <dd>Returns the number of seconds remaining until the battery is fully charged.</dd>
        <dt><code>battery.dischargingTime</code></dt>
        <dd>Returns the number of seconds remaining until the battery is fully discharged.</dd>
        <dt><code>battery.level</code></dt>
        <dd>Returns the battery charging level as the number in 0 to 1 range.</dd>
        <dt><code>battery.addEventListener('chargingchange', listener)</code></dt>
        <dd>An event fired when <code>battery.charging</code> value has changed.</dd>
        <dt><code>battery.addEventListener('chargingtimechange', listener)</code></dt>
        <dd>An event fired when <code>battery.chargingTime</code> value has changed.</dd>
        <dt><code>battery.addEventListener('dischargingtimechange', listener)</code></dt>
        <dd>An event fired when <code>battery.dischargingTime</code> value has changed.</dd>
        <dt><code>battery.addEventListener('levelchange', listener)</code></dt>
        <dd>An event fired when <code>battery.level</code> value has changed.</dd>
      </dl>`,
      caniuse: 'battery-status',
      tests: [
        Feature.navigatorContains('getBattery'),
        Feature.navigatorContains('battery')
      ],
      demo: {
        html: `<p>Initial battery status was <b id="charging">unknown</b>, charging time <b id="chargingTime">unknown</b>, discharging time <b id="dischargingTime">unknown</b>, level <b id="level">unknown</b>.</p>

<div id="target"></div>`,
        js: `if ('getBattery' in navigator || ('battery' in navigator && 'Promise' in window)) {
  var target = document.getElementById('target');

  function handleChange(change) {
    var timeBadge = new Date().toTimeString().split(' ')[0];
    var newState = document.createElement('p');
    newState.innerHTML = '<span class="badge">' + timeBadge + '</span> ' + change + '.';
    target.appendChild(newState);
  }
  
  function onChargingChange() {
    handleChange('Battery charging changed to <b>' + (this.charging ? 'charging' : 'discharging') + '</b>')
  }
  function onChargingTimeChange() {
    handleChange('Battery charging time changed to <b>' + this.chargingTime + ' s</b>');
  }
  function onDischargingTimeChange() {
    handleChange('Battery discharging time changed to <b>' + this.dischargingTime + ' s</b>');
  }
  function onLevelChange() {
    handleChange('Battery level changed to <b>' + this.level + '</b>');
  }

  var batteryPromise;
  
  if ('getBattery' in navigator) {
    batteryPromise = navigator.getBattery();
  } else {
    batteryPromise = Promise.resolve(navigator.battery);
  }
  
  batteryPromise.then(function (battery) {
    document.getElementById('charging').innerHTML = battery.charging ? 'charging' : 'discharging';
    document.getElementById('chargingTime').innerHTML = battery.chargingTime + ' s';
    document.getElementById('dischargingTime').innerHTML = battery.dischargingTime + ' s';
    document.getElementById('level').innerHTML = battery.level;
    
    battery.addEventListener('chargingchange', onChargingChange);
    battery.addEventListener('chargingtimechange', onChargingTimeChange);
    battery.addEventListener('dischargingtimechange', onDischargingTimeChange);
    battery.addEventListener('levelchange', onLevelChange);
  });
}`,
        jsOnExit: `if ('getBattery' in navigator || ('battery' in navigator && 'Promise' in window)) {
  var batteryPromise;
  
  if ('getBattery' in navigator) {
    batteryPromise = navigator.getBattery();
  } else {
    batteryPromise = Promise.resolve(navigator.battery);
  }
  
  batteryPromise.then(function (battery) {
    battery.removeEventListener('chargingchange', onChargingChange);
    battery.removeEventListener('chargingtimechange', onChargingTimeChange);
    battery.removeEventListener('dischargingtimechange', onDischargingTimeChange);
    battery.removeEventListener('levelchange', onLevelChange);
  });
}`
      },
      links: [
        {url: 'https://w3c.github.io/battery/', title: 'Specification Draft'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/Battery_Status_API', title: 'MDN: Battery Status API'}
      ]
    }),

    storage: new Feature({
      id: 'storage',
      name: 'Offline Storage',
      description: [
        `There were <a href="http://diveinto.html5doctor.com/storage.html" target="_blank">several iterations</a> of prototypes
          and standardized technologies for offline storage capabilities for Web applications. First attempts were either just hacky workarounds
          (like to store data in cookies) or required additional software (like Flash or Google Gears). Later, Web SQL idea, basically to include SQLite
          natively within a browser, was coined and <a href="http://caniuse.com/#feat=sql-storage" target="_blank">implemented throughout some browsers</a>,
          but deprecated later <a href="https://hacks.mozilla.org/2010/06/beyond-html5-database-apis-and-the-road-to-indexeddb/" target="_blank">due to
          the standardization difficulties</a>.`,
        `Right now there are at least three distinct and independent technologies standardized and available. The simplest one is <b>Web Storage</b> - 
          a key-value string storage, allowing Web applications to store data either persistently and cross-window (<code>localStorage</code>) 
          or for a single session in a single browser tab (<code>sessionStorage</code>). The more sophisticated <b>IndexedDB</b> is a low-level API
          over database-like structures with transactions and cursors iterating by indexes. The newest addition - <b>Cache API</b> is a specialized
          solution to keep <code>Request</code>/<code>Response</code> pairs, useful mostly within <a href="/offline.html">Service Worker</a> implementation.`,
        `Live example and usage data shown here are referring to <b>Web Storage</b> engine. For details on IndexedDB,
          refer to <a href="http://caniuse.com/#feat=indexeddb" target="_blank">caniuse.com</a>.`,
        `The actual persistence of data stored in any of the persistent stores (be it <code>localStorage</code>, IndexedDB or Cache API) is browser-managed
          and by default might be wiped out without end-user consent in case of memory pressure conditions. To address this problem, <b>Storage API</b>
          was introduced - it gives the Web applications a method to store the data in a fully reliable way if the user permits it to do so. Chrome's
          implementation grants this permission based on user-engagement-based heuristic, while Firefox asks for the permission explicitly.`
      ],
      api: `<p><b>Web Storage API</b></p>
      <dl>
        <dt><code>window.sessionStorage</code></dt>
        <dd>Gives an access to the Web Storage engine with per-session objects lifetime.</dd>
        <dt><code>window.localStorage</code></dt>
        <dd>Gives an access to the Web Storage engine with persistent objects lifetime.</dd>
        <dt><code>storage.setItem(key, value)</code></dt>
        <dd>Saves the <code>value</code> string under the <code>key</code> in the selected storage engine.</dd>
        <dt><code>storage.getItem(key)</code></dt>
        <dd>Returns the string value stored under the <code>key</code> in the selected storage engine.</dd>
        <dt><code>storage.removeItem(key)</code></dt>
        <dd>Removes the string value stored under the <code>key</code> from the selected storage engine.</dd>
        <dt><code>storage.clear()</code></dt>
        <dd>Removes all the string values stored in the selected storage engine.</dd>
        <dt><code>window.addEventListener('storage', listener)</code></dt>
        <dd>An event fired when the data stored in either <code>sessionStorage</code> or <code>localStorage</code> has been changed externally.</dd>
      </dl>
      <p><b>IndexedDB</b></p>
      <dl>
        <dt><code>let openRequest = window.indexedDB.open(name, version)</code></dt>
        <dd>Triggers opening a database connection to either existing or newly-created database. 
          Returns an object that fires <code>success</code> event when the connection is established.</dd>
        <dt><code>let db = openRequest.result</code></dt>
        <dd>Gives an access to the open database connection instance - available after <code>success</code> was fired.</dd>
        <dt><code>db.createObjectStore(storeName, options)</code></dt>
        <dd>Creates a named container (object store) for objects in the opened database.</dd>
        <dt><code>let tx = db.transaction(storeName)</code></dt>
        <dd>Opens a data-reading or data-manipulation transaction scoped to the given object store(s).</dd>
        <dt><code>tx.objectStore.put(value, key)</code></dt>
        <dd>Saves the <code>value</code> in the currently opened object store.</dd>
        <dt><code>tx.objectStore.get(key)</code></dt>
        <dd>Gets the object stored under a <code>key</code> in the currently opened object store.</dd>
        <dt><code>tx.createIndex(name, keyPath, options)</code></dt>
        <dd>Creates an index that allows to seek for the stored objects using the property specified via <code>keyPath</code>.</dd>
        <dt><code>tx.index(name).get(key)</code></dt>
        <dd>Gets the object having the particular index <code>keyPath</code> equal to the <code>key</code> specified.</dd>
      </dl>
      <p><b>Cache API</b></p>
      <dl>
        <dt><code>let cache = window.caches.open(key)</code></dt>
        <dd>Returns a <code>Promise</code> that resolves to a store "bucket" object giving an access to the cached <code>Response</code> objects.</dd>
        <dt><code>cache.put(request, response)</code></dt>
        <dd>Saves the <code>Response</code> object to the cache with its corresponding <code>Request</code> object.</dd>
        <dt><code>cache.match(request, option)</code></dt>
        <dd>Returns a <code>Promise</code> that resolves to the <code>Response</code> object matching the specified <code>Request</code> 
          (with the <code>options</code>-controlled level of exactness) found in the opened cache "bucket".</dd>
        <dt><code>cache.delete(request, option)</code></dt>
        <dd>Removes the <code>Response</code> object matching the specified <code>Request</code>
          (with the <code>options</code>-controlled level of exactness) found in the opened cache "bucket".</dd>
      </dl>
      <p><b>Storage API (persistence permission)</b></p>
      <dl>
        <dt><code>navigator.storage.persist()</code></dt>
        <dd>Requests a permission to turn the data saved by the Web application into persistent data. 
          Returns a <code>Promise</code> that resolves with a boolean value indicating whether the permission was granted.</dd>
        <dt><code>navigator.storage.persisted()</code></dt>
        <dd>Returns a <code>Promise</code> that resolves with a boolean value indicating whether the persistent storage permission was already granted.</dd>
      </dl>`,
      caniuse: 'namevalue-storage',
      tests: [
        Feature.windowContains('sessionStorage'),
        Feature.windowContains('localStorage'),
        Feature.windowContains('indexedDB'),
        Feature.windowContains('caches'),
        Feature.navigatorContains('storage')
      ],
      demo: {
        html: `<p>
  <label>Engine</label>
</p>
<div class="btn-group" role="group" id="selectEngine">
  <button type="button" class="btn btn-default" data-engine="localStorage">Persistent Storage</button>
  <button type="button" class="btn btn-default" data-engine="sessionStorage">Per-Session Storage</button>
</div>

<p>
  <label for="value">Value for <code>myKey</code></label>
  <input type="text" class="form-control" id="value">
</p>

<p>Open the example in another tab and change the value there to see the synchronization via <code>storage</code> event.</p>
<div id="target"></div>`,
        js: `if ('localStorage' in window || 'sessionStorage' in window) {
  var selectedEngine;

  var logTarget = document.getElementById('target');
  var valueInput = document.getElementById('value');

  var reloadInputValue = function () {
    valueInput.value =  window[selectedEngine].getItem('myKey') || '';
  }
  
  var selectEngine = function (engine) {
    document.querySelector('[data-engine=' + engine + ']').classList.add('active');
    if (selectedEngine) {
      document.querySelector('[data-engine=' + selectedEngine + ']').classList.remove('active');
    }

    selectedEngine = engine;
    reloadInputValue();
  };

  var getSelectEngineFn = function (button) {
    return function () {
      var engine = button.getAttribute('data-engine');
      if (selectedEngine !== engine) {
        selectEngine(engine);
      }
    };
  };

  function handleChange(change) {
    var timeBadge = new Date().toTimeString().split(' ')[0];
    var newState = document.createElement('p');
    newState.innerHTML = '<span class="badge">' + timeBadge + '</span> ' + change + '.';
    logTarget.appendChild(newState);
  }

  var buttons = document.querySelectorAll('#selectEngine button');
  for (var i = 0; i < buttons.length; ++i) {
    buttons[i].addEventListener('click', getSelectEngineFn(buttons[i]));
  }
  
  selectEngine('localStorage');

  valueInput.addEventListener('keyup', function () {
    window[selectedEngine].setItem('myKey', this.value);
  });

  var onStorageChanged = function (change) {
    var engine = change.storageArea === window.localStorage ? 'localStorage' : 'sessionStorage';
    handleChange('External change in <b>' + engine + '</b>: key <b>' + change.key + '</b> changed from <b>' + change.oldValue + '</b> to <b>' + change.newValue + '</b>');
    if (engine === selectedEngine) {
      reloadInputValue();
    }
  }

  window.addEventListener('storage', onStorageChanged);
}`,
        jsOnExit: `window.removeEventListener('storage', onStorageChanged);`
      },
      links: [
        {url: 'https://html.spec.whatwg.org/multipage/webstorage.html', title: 'Web Storage Specification'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API', title: 'MDN: Web Storage API'},
        {url: 'https://www.w3.org/TR/IndexedDB/', title: 'IndexedDB Specification'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API', title: 'MDN: IndexedDB API'},
        {url: 'https://w3c.github.io/ServiceWorker/v1/#cache', title: 'Cache API Specification'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/Cache', title: 'MDN: Cache API'},
        {url: 'https://storage.spec.whatwg.org/', title: 'Storage API Specification'},
        {url: 'https://developers.google.com/web/updates/2016/06/persistent-storage', title: 'Google Developers: Persistent Storage'}
      ]
    }),

    files: new Feature({
      id: 'files',
      name: 'File Access',
      description: `The <b>File API</b> gives Web applications an access to the filesystem-level information about the files that the user decides to share
        with the application, i.e. size, MIME type, modification date, content, without sending the file to the server.`,
      api: `<dl>
        <dt><code>fileInputElement.files</code></dt>
        <dd>Returns a collection of file objects that were selected by the user using <code>&lt;input type="file"&gt;</code>DOM element.</dd>
        <dt><code>file.name</code></dt>
        <dd>Returns the original name of the file, without the path.</dd>
        <dt><code>file.size</code></dt>
        <dd>Returns the file size in bytes.</dd>
        <dt><code>file.type</code></dt>
        <dd>Returns the file's MIME type.</dd>
        <dt><code>file.lastModifiedDate</code></dt>
        <dd>Returns the file's last modification date.</dd>
        <dt><code>fileReader.readAsText(file)</code></dt>
        <dd>Initiates a process of reading the file and encoding its content as text.</dd>
        <dt><code>fileReader.addEventListener('load', listener)</code></dt>
        <dd>An event fired when the reading operation has completed successfully. The data read is available via <code>fileReader.result</code> property.</dd>
      </dl>`,
      caniuse: 'fileapi',
      tests: [Feature.windowContains('File')],
      demo: {
        html: `<span class="btn btn-default btn-file">
    Choose some files <input type="file" onchange="handleFiles(this.files)" multiple>
</span>

<p>Number of selected files: <b id="count">N/A</b></p>

<ul id="target"></ul>`,
        css: `.btn-file {
    position: relative;
    overflow: hidden;
    margin: 10px;
}
.btn-file input[type=file] {
    position: absolute;
    top: 0;
    right: 0;
    min-width: 100%;
    min-height: 100%;
    opacity: 0;
    outline: none;
    background: #fff;
    cursor: inherit;
    display: block;
}`,
        js: `function getReadFile(reader, i) {
  return function () {
    var li = document.querySelector('[data-idx="' + i + '"]');

    li.innerHTML += 'File starts with "' + reader.result.substr(0, 25) + '"';
  }
}

function handleFiles(files) {
  document.getElementById('count').innerHTML = files.length;

  var target = document.getElementById('target');
  target.innerHTML = '';

  for (var i = 0; i < files.length; ++i) {
    var item = document.createElement('li');
    item.setAttribute('data-idx', i);
    var file = files[i];

    var reader = new FileReader();
    reader.addEventListener('load', getReadFile(reader, i));
    reader.readAsText(file);

    item.innerHTML = '<b>' + file.name + '</b>, ' + file.type + ', ' + file.size + ' bytes, last modified ' + file.lastModifiedDate + '<br>';
    target.appendChild(item);
  };
}`
      },
      links: [
        {url: 'https://w3c.github.io/FileAPI/', title: 'Specification Draft'},
        {
          url: 'https://developer.mozilla.org/en-US/docs/Using_files_from_web_applications',
          title: 'MDN: Using files from Web applications'
        },
        {url: 'http://www.html5rocks.com/en/tutorials/file/dndfiles/', title: 'Reading files in JavaScript using the File APIs'}
      ]
    }),

    permissions: new Feature({
      id: 'permissions',
      name: 'Permissions',
      description: `The <b>Permissions API</b> provides the uniform way for Web applications to query for the permission status for the features
        that might require user consent, like notifications or geolocation. With Permissions API the app can list the permissions
        granted by the user without actually triggering the feature itself.`,
      api: `<dl>
        <dt><code>navigator.permissions.query({name: feature})</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the object representing the permission status of the requested feature.</dd>
        <dt><code>permissionStatus.state</code></dt>
        <dd>Returns the permission status of the requested feature, either <code>granted</code>, <code>denied</code> or - in case the user was not yet asked - <code>prompt</code>.</dd>
        <dt><code>permissionStatus.addEventListener('change', listener)</code></dt>
        <dd>An event fired when the permission status of the requested feature has changed.</dd>
      </dl>`,
      caniuse: 'permissions-api',
      tests: [Feature.navigatorContains('permissions')],
      demo: {
        html: `<div>
  <p>
    <b><a href="/geolocation.html">Geolocation</a></b> permission status is <b id="geolocation-status">unknown</b>.
    
    <button class="btn btn-sm btn-default" onclick="requestGeolocation()">Request</button>
  </p>
  <p>
    <b><a href="/local-notifications.html">Notifications</a></b> permission status is <b id="notifications-status">unknown</b>.
    
    <button class="btn btn-default" onclick="requestNotifications()">Request</button>
  </p>
  <p>
    <b><a href="/push-notifications.html">Push</a></b> permission status is <b id="push-status">unknown</b>.
    
    <button class="btn btn-default" onclick="requestPush()">Request</button>
  </p>
  <p>
    <b>Midi</b> permission status is <b id="midi-status">unknown</b>.
    
    <button class="btn btn-default" onclick="requestMidi()">Request</button>
  </p>
  <p>
    <b><a href="/camera-microphone.html">Camera</a></b> permission status is <b id="camera-status">unknown</b>.
    
    <button class="btn btn-default" onclick="requestCamera()">Request</button>
  </p>
  <p>
    <b><a href="/camera-microphone.html">Microphone</a></b> permission status is <b id="microphone-status">unknown</b>.
    
    <button class="btn btn-default" onclick="requestMicrophone()">Request</button>
  </p>
  <p>
    <b><a href="/background-sync.html">Background Sync</a></b> permission status is <b id="background-sync-status">unknown</b>.
  </p>
  <p>
    <b><a href="/ambient-light.html">Ambient Light Sensor</a></b> permission status is <b id="ambient-light-sensor-status">unknown</b>.
  </p>
  <p>
    <b><a href="/device-motion.html">Accelerometer</a></b> permission status is <b id="accelerometer-status">unknown</b>.
  </p>
  <p>
    <b><a href="/device-motion.html">Gyroscope</a></b> permission status is <b id="gyroscope-status">unknown</b>.
  </p>
  <p>
    <b><a href="/device-motion.html">Magnetometer</a></b> permission status is <b id="magnetometer-status">unknown</b>.
  </p>
</div>

<p id="logTarget"></p>`,
        js: `if ('permissions' in navigator) {
  var logTarget = document.getElementById('logTarget');

  function handleChange(permissionName, newState) {
    var timeBadge = new Date().toTimeString().split(' ')[0];
    var newStateInfo = document.createElement('p');
    newStateInfo.innerHTML = '<span class="badge">' + timeBadge + '</span> State of <b>' + permissionName + '</b> permission status changed to <b>' + newState + '</b>.';
    logTarget.appendChild(newStateInfo);
  }

  function checkPermission(permissionName, descriptor) {
    try {
    navigator.permissions.query(Object.assign({name: permissionName}, descriptor))
      .then(function (permission) {
        document.getElementById(permissionName + '-status').innerHTML = permission.state;
        permission.addEventListener('change', function (e) {
          document.getElementById(permissionName + '-status').innerHTML = permission.state;
          handleChange(permissionName, permission.state);
        });
      });
    } catch (e) {
    }
  }

  checkPermission('geolocation');
  checkPermission('notifications');
  checkPermission('push', {userVisibleOnly: true});
  checkPermission('midi', {sysex: true});
  checkPermission('camera');
  checkPermission('microphone');
  checkPermission('background-sync');
  checkPermission('ambient-light-sensor');
  checkPermission('accelerometer');
  checkPermission('gyroscope');
  checkPermission('magnetometer');

  var noop = function () {};
  navigator.getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
  
  function requestGeolocation() {
    navigator.geolocation.getCurrentPosition(noop);
  }

  function requestNotifications() {
    Notification.requestPermission();
  }

  function requestPush() {
    navigator.serviceWorker.getRegistration()
      .then(function (serviceWorkerRegistration) {
        serviceWorkerRegistration.pushManager.subscribe();
      });
  }

  function requestMidi() {
    navigator.requestMIDIAccess({sysex: true});
  }
  
  function requestCamera() {
    navigator.getUserMedia({video: true}, noop, noop)
  }
  
  function requestMicrophone() {
    navigator.getUserMedia({audio: true}, noop, noop)
  }
}`,
        cssHidden: `#demo-placeholder {
  overflow: hidden;
}

#logTarget, #demo-placeholder div {
  float: left;
  width: 50%;
}`
      },
      links: [
        {url: 'https://w3c.github.io/permissions/', title: 'Specification Draft'},
        {url: 'https://developers.google.com/web/updates/2015/04/permissions-api-for-the-web', title: 'Permissions API for the Web'},
        {url: 'https://permission.site', title: 'Permissions Demo'}
      ]
    }),

    contacts: new Feature({
      id: 'contacts',
      name: 'Contacts',
      description: [`The <b>Contacts API</b> gives privileged Web applications a programmatic access to the user's address book maintained in the system.`,
        `The initial version of the API was created for Firefox OS back in 2013 and implemented in Firefox. It allowed reading & modifying the contacts through the vCard-like format.
         It was soon <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=927869" target="_blank">disabled</a> due to implementation flaws, though.`,
        `The second proposal to provide Web applications with the ability to interact with the address book was initiated by Google Chrome in late 2018. The new proposal targets 
         specifically the read-only scenario of picking the contacts to be used within the client application only – no modification is to be supported by the API. The proposal is not yet implemented, though.`,
        `Regardless from the programmatic access to the contacts API availability, the Web applications might ask for pre-filling the form data from the device address book with the help of 
         <a href="https://www.w3.org/TR/html51/sec-forms.html#element-attrdef-autocompleteelements-autocomplete" target="_blank">form elements' <code>autocomplete</code> attribute values</a>.`],
      api: `<p><b>Google Chrome proposal (2018)</b></p>
      <dl>
        <dt><code>navigator.contacts.select(filterOptions)</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the array of contacts from the address book according to the criteria specified.</dd>
      </dl>
      <p><b>Firefox OS API (2013)</b></p>
      <dl>
        <dt><code>navigator.contacts.find(filterAndSortOptions)</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the array of contacts from the address book according to the criteria specified.</dd>
        <dt><code>navigator.contacts.save(new Contact())</code></dt>
        <dd>Returns a <code>Promise</code> resolved when the newly created contact is inserted into the address book.</dd>
        <dt><code>navigator.contacts.remove(contact)</code></dt>
        <dd>Returns a <code>Promise</code> resolved when the contact is removed from the address book.</dd>
        <dt><code>navigator.contacts.addEventListener('contactschange', listener)</code></dt>
        <dd>An event fired when the address book data has changed, containing all the added, removed and changed contact entries.</dd>
      </dl>`,
      tests: [
        Feature.containedIn('navigator.contacts', global.navigator && global.navigator.contacts, 'select'), // Chrome API
        Feature.containedIn('navigator.contacts', global.navigator && (global.navigator.contacts || global.navigator.mozContacts), 'oncontactschange', false) // Firefox OS API
      ],
      demo: {
        html: `<p>
  <button class="btn btn-lg btn-default" onclick="readContacts()">Read Contacts</button>
</p>

<pre id="log"></pre>
`,
        js: `function readContacts() {
  var api = (navigator.contacts || navigator.mozContacts);
    
  if (api && !!api.select) { // new Chrome API
    api.select({
      properties: ['name', 'email'],
      multiple: true
    })
      .then(function (contacts) {
        consoleLog('Found ' + contacts.length + ' contacts.');
        if (contacts.length) {
          consoleLog('First contact: ' + contacts[0].name + ' (' + contacts[0].email + ')');
        }
      })
      .catch(function (err) {
        consoleLog('Fetching contacts failed: ' + err.name);
      });
      
  } else if (api && !!api.find) { // old Firefox OS API
    var criteria = {
      sortBy: 'familyName',
      sortOrder: 'ascending'
    };

    api.find(criteria)
      .then(function (contacts) {
        consoleLog('Found ' + contacts.length + ' contacts.');
        if (contacts.length) {
          consoleLog('First contact: ' + contacts[0].givenName[0] + ' ' + contacts[0].familyName[0]);
        }
      })
      .catch(function (err) {
        consoleLog('Fetching contacts failed: ' + err.name);
      });
      
  } else {
    consoleLog('Contacts API not supported.');
  }
}

function consoleLog(data) {
  var logElement = document.getElementById('log');
  logElement.innerHTML += data + '\\n';
}`
      },
      links: [
        {url: 'https://github.com/beverloo/contact-api', title: 'Specification Proposal by Google Chrome (2018)'},
        {url: 'https://cloudfour.com/thinks/autofill-what-web-devs-should-know-but-dont/', title: 'Article about auto-fill attribute values support'},
        {url: 'https://www.w3.org/TR/contacts-manager-api/', title: 'Specification Draft (pre-2015)'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/Contacts_API', title: 'MDN: Contacts API (Firefox OS version)'}
      ]
    }),

    quota: new Feature({
      id: 'storage-quota',
      name: 'Storage Quotas',
      description: [
        `There were several attempts made, mostly by Google Chrome, to allow Web applications to query the system for the size of the storage space
         currently used and available for the application. The most recent one, <b>Quota Estimation API</b>, is also in development in Firefox as of June 2017.`,
        `The older implementation, supported only in Chrome with <code>webkit-</code> prefix, maintained a separation between the temporary and persistent storage
         and allowed the Web applications to request for more storage space, if needed.`
      ],
      api: `<dl>
        <dt><code>navigator.storage.estimate()</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the storage space estimated values; see below.</dd>
        <dt><code>estimate.usage</code></dt>
        <dd>Returns the estimated size of the storage currently used by the application, in bytes.</dd>
        <dt><code>estimate.quota</code></dt>
        <dd>Returns the estimated total size of the storage available for the application, in bytes, including already used.</dd>
      </dl>`,
      tests: [
        Feature.containedIn('navigator.storage', (global.navigator || {}).storage, 'estimate'),
        Feature.navigatorContains('persistentStorage', false)
      ],
      demo: {
        html: `<p>Estimated storage usage is <b id="usage">unknown</b> bytes.</p>
<p>Estimated storage quota is <b id="quota">unknown</b> bytes.</p>
<p>Estimated usage is <b id="percent">unknown</b>%.</p>`,
        js: `if ('storage' in navigator && 'estimate' in navigator.storage) {
  navigator.storage.estimate()
    .then(estimate => {
      document.getElementById('usage').innerHTML = estimate.usage;
      document.getElementById('quota').innerHTML = estimate.quota;
      document.getElementById('percent').innerHTML = (estimate.usage * 100 / estimate.quota).toFixed(0);
    });
}`
      },
      links: [
        {url: 'https://storage.spec.whatwg.org/', title: 'Specification Draft'},
        {url: 'http://www.html5rocks.com/en/tutorials/offline/quota-research/', title: 'Quota limitations analysis'}
      ]
    }),

    touch: new Feature({
      id: 'touch',
      name: 'Touch Gestures',
      description: [`Traditionally, Web relies on a mouse and a keyboard as the only input devices, while mobile devices are mostly controlled by touch.
        Mobile Web started with a bit touchy solution of translating touch events to mouse events like <code>mousedown</code>.`,
        `Newer HTML5 approach is to embrace touch as the first-class input mean, allowing Web applications to intercept and identify complex multitouch
         gestures, free-hand drawing etc. Unfortunately, the support is twofold - either via touch events like <code>touchstart</code> that were first
         introduced by Apple and standardized later as a de-facto solution, when other vendors went the same route, or via the newer,
         more general <b>Pointer Events</b> specification, initiated by Microsoft.`],
      api: `<p><b>Touch Events API</b></p>
        <dl>
          <dt><code>element.addEventListener('touchstart', listener)</code></dt>
          <dd>An event triggered when the finger has been placed on a DOM element.</dd>
          <dt><code>element.addEventListener('touchmove', listener)</code></dt>
          <dd>An event triggered when the finger has been dragged along a DOM element.</dd>
          <dt><code>element.addEventListener('touchend', listener)</code></dt>
          <dd>An event triggered when the finger has been removed from a DOM element.</dd>
        </dl>
        <p><b>Pointer Events API</b></p>
        <dl>
          <dt><code>element.addEventListener('pointerdown', listener)</code></dt>
          <dd>An event triggered when the finger has been placed on a DOM element.</dd>
          <dt><code>element.addEventListener('pointermove', listener)</code></dt>
          <dd>An event triggered when the finger has been dragged along a DOM element.</dd>
          <dt><code>element.addEventListener('pointerup', listener)</code></dt>
          <dd>An event triggered when the finger has been removed from a DOM element.</dd>
        </dl>`,
      //caniuse: ['touch', 'pointer'], //TODO multiple caniuse refs
      caniuse: 'touch',
      demo: {
        html: `<div class="test-element">Drag me with one finger</div>
<div class="test-element">Drag me with another finger</div>
<div class="test-element">Drag me too</div>

<p><small>Based on demo from <a href="https://www.quirksmode.org/m/tests/drag2.html">QuirksMode.org</a>.</small></p>`,
        css: `.test-element {
  height: 100px;
  background-color: black;
  width: 100px;
  z-index: 5;
  position: absolute;
  top: 15px;
  left: 15px;
  color: white;
  text-align: center;
  -ms-touch-action: none;
}

.test-element:nth-child(2) {
  top: 150px;
  left: 150px;
}

.test-element:nth-child(3) {
  top: 50px;
  left: 100px;
}`,
        cssHidden: `#demo-placeholder {
  min-height: 300px;
}`,
        js: `function startDrag(e) {
  this.ontouchmove = this.onmspointermove = moveDrag;

  this.ontouchend = this.onmspointerup = function () {
    this.ontouchmove = this.onmspointermove = null;
    this.ontouchend = this.onmspointerup = null;
  }

  var pos = [this.offsetLeft, this.offsetTop];
  var that = this;
  var origin = getCoors(e);

  function moveDrag(e) {
    var currentPos = getCoors(e);
    var deltaX = currentPos[0] - origin[0];
    var deltaY = currentPos[1] - origin[1];
    this.style.left = (pos[0] + deltaX) + 'px';
    this.style.top = (pos[1] + deltaY) + 'px';
    return false; // cancels scrolling
  }

  function getCoors(e) {
    var coors = [];
    if (e.targetTouches && e.targetTouches.length) {
      var thisTouch = e.targetTouches[0];
      coors[0] = thisTouch.clientX;
      coors[1] = thisTouch.clientY;
    } else {
      coors[0] = e.clientX;
      coors[1] = e.clientY;
    }
    return coors;
  }
}

var elements = document.querySelectorAll('.test-element');
[].forEach.call(elements, function (element) {
  element.ontouchstart = element.onmspointerdown = startDrag;
});

document.ongesturechange = function () {
  return false;
}`
      },
      tests: [
        Feature.windowContains('ontouchstart'),
        Feature.windowContains('onpointerdown')
      ],
      links: [
        {url: 'https://w3c.github.io/touch-events/', title: 'Touch Events API Specification'},
        {url: 'https://w3c.github.io/pointerevents/', title: 'Pointer Events API Specification Draft'},
        {url: 'http://www.quirksmode.org/mobile/tableTouch.html', title: 'Detailed support table'},
        {url: 'http://www.html5rocks.com/en/mobile/touch/', title: 'Multi-touch Web Development'}
      ]
    }),

    deviceMotion: new Feature({
      id: 'device-motion',
      aliases: ['accelerometer'],
      name: 'Device Motion',
      description: [`The first-generation device motions support is a part of <b>Device Orientation API</b>. It allows Web applications to access the accelerometer data
        expressed as acceleration (in m/s<sup>2</sup>) and gyroscope data expressed as rotation angle change (in &deg;/s) for each of the three dimensions, provided as events.`,
        `There also exist the newer, separate specifications for each sensor type, based on the <b>Generic Sensor API</b> - the APIs providing direct access to the readings
        of physical devices (<b>Accelerometer API</b>, <b>Gyroscope API</b> and <b>Magnetometer API</b>) as well as high-level fusion sensors made up by combining
         the readings of the physical sensors (<b>Linear Acceleration Sensor API</b> and <b>Gravity Sensor API</b>). The newer API is available experimentally in Google Chrome via <a href="https://github.com/GoogleChrome/OriginTrials/blob/gh-pages/developer-guide.md" target="_blank">Origin Trial</a> up until April 2018.`,
        `For the detection of the device's static position and orientation, see <a href="/device-position.html">Device Position</a>.`],
      api: `<p><b>As a part of Device Orientation API</b></p>
      <dl>
        <dt><code>window.addEventListener('devicemotion', listener)</code></dt>
        <dd>An event fired when the significant changes in the device's acceleration or rotation has occured.</dd>
        <dt><code>event.acceleration</code></dt>
        <dd>A part of the event's payload returning the data about the current device's acceleration excluding gravity for all three axes
         (<code>acceleration.x</code>, <code>acceleration.y</code>, <code>acceleration.z</code>).</dd>
        <dt><code>event.accelerationIncludingGravity</code></dt>
        <dd>A part of the event's payload returning the data about the current device's acceleration including gravity if the device is unable
          to provide the data without the gravity effect using <code>event.acceleration</code>.</dd>
        <dt><code>event.rotationRate</code></dt>
        <dd>A part of the event's payload returning the data about the current device's rotation rates for all three axes
         (<code>rotationRate.alpha</code>, <code>rotationRate.beta</code>, <code>rotationRate.gamma</code>).</dd>
        <dt><code>event.interval</code></dt>
        <dd>A part of the event's payload returning the interval (in ms) at which the data is obtained from the accelerometer.</dd>
      </dl>
      <p><b>Accelerometer API</b></p>
      <dl>
        <dt><code>sensor = new Accelerometer()</code></dt>
        <dd>Creates an object serving as a direct accessor to the accelerometer readings.</dd>
        <dt><code>sensor.addEventListener('reading', listener)</code></dt>
        <dd>An event fired when the accelerometer reading has changed, indicating that the sensor object contains updated acceleration in rad/s for all three axes (<code>sensor.x</code>, <code>sensor.y</code>, <code>sensor.z</code>).</dd>
        <dt><code>sensor.start()</code></dt>
        <dd>Starts listening for the sensor readings.</dd>
      </dl>
      <p><b>Gyroscope API</b></p>
      <dl>
        <dt><code>sensor = new Gyroscope()</code></dt>
        <dd>Creates an object serving as a direct accessor to the gyroscope readings.</dd>
        <dt><code>sensor.addEventListener('reading', listener)</code></dt>
        <dd>An event fired when the gyroscope reading has changed, indicating that the sensor object contains updated angular velocity in rad/s for all three axes (<code>sensor.x</code>, <code>sensor.y</code>, <code>sensor.z</code>).</dd>
        <dt><code>sensor.start()</code></dt>
        <dd>Starts listening for the sensor readings.</dd>
      </dl>
      <p><b>Magnetometer API</b></p>
      <dl>
        <dt><code>sensor = new Magnetometer()</code></dt>
        <dd>Creates an object serving as a direct accessor to the magnetometer readings.</dd>
        <dt><code>sensor.addEventListener('reading', listener)</code></dt>
        <dd>An event fired when the magnetometer reading has changed, indicating that the sensor object contains updated magnetic field for all three axes (<code>sensor.x</code>, <code>sensor.y</code>, <code>sensor.z</code>).</dd>
        <dt><code>sensor.start()</code></dt>
        <dd>Starts listening for the sensor readings.</dd>
      </dl>
      <p><b>Linear Acceleration Sensor API</b></p>
      <dl>
        <dt><code>sensor = new LinearAccelerationSensor()</code></dt>
        <dd>Creates an object serving as an accessor to the linear acceleration readings based on accelerometer and either gyroscope or magnetometer.</dd>
        <dt><code>sensor.addEventListener('reading', listener)</code></dt>
        <dd>An event fired when the accelerometer reading has changed, indicating that the sensor object contains updated acceleration values in m/s<sup>2</sup> for all three axes (<code>sensor.x</code>, <code>sensor.y</code>, <code>sensor.z</code>).</dd>
        <dt><code>sensor.start()</code></dt>
        <dd>Starts listening for the sensor readings.</dd>
      </dl>
      <p><b>Gravity Sensor API</b></p>
      <dl>
        <dt><code>sensor = new GravitySensor()</code></dt>
        <dd>Creates an object serving as an accessor to the gravity readings based on accelerometer and gyroscope.</dd>
        <dt><code>sensor.addEventListener('reading', listener)</code></dt>
        <dd>An event fired when the accelerometer reading has changed, indicating that the sensor object contains updated acceleration values in m/s<sup>2</sup> for all three axes (<code>sensor.x</code>, <code>sensor.y</code>, <code>sensor.z</code>).</dd>
        <dt><code>sensor.start()</code></dt>
        <dd>Starts listening for the sensor readings.</dd>
      </dl>`,
      caniuse: 'deviceorientation',
      tests: [
        Feature.windowContains('DeviceMotionEvent'),
        Feature.windowContains('Accelerometer'),
        Feature.windowContains('Gyroscope'),
        Feature.windowContains('Magnetometer'),
        Feature.windowContains('LinearAccelerationSensor'),
        Feature.windowContains('GravitySensor'),
      ],
      demo: {
        html: `<table class="table table-striped table-bordered">
  <tr>
    <td>API used</td>
    <td id="moApi"></td>
  </tr>
  <tr>
    <td>linear acceleration (excl. gravity)</td>
    <td id="moAccel"></td>
  </tr>
  <tr>
    <td>acceleration incl. gravity</td>
    <td id="moAccelGrav"></td>
  </tr>
  <tr>
    <td>rotation rate</td>
    <td id="moRotation"></td>
  </tr>
  <tr>
    <td>interval (ms)</td>
    <td id="moInterval"></td>
  </tr>
</table>

<p><small>Demo based on <a href="https://www.html5rocks.com/en/tutorials/device/orientation/" target="_blank">HTML5 Rocks</a> article.</small></p>`,
        js: `if ('LinearAccelerationSensor' in window && 'Gyroscope' in window) {
  document.getElementById('moApi').innerHTML = 'Generic Sensor API';
  
  let lastReadingTimestamp;
  let accelerometer = new LinearAccelerationSensor();
  accelerometer.addEventListener('reading', e => {
    if (lastReadingTimestamp) {
      intervalHandler(Math.round(accelerometer.timestamp - lastReadingTimestamp));
    }
    lastReadingTimestamp = accelerometer.timestamp
    accelerationHandler(accelerometer, 'moAccel');
  });
  accelerometer.start();
  
  if ('GravitySensor' in window) {
    let gravity = new GravitySensor();
    gravity.addEventListener('reading', e => accelerationHandler(gravity, 'moAccelGrav'));
    gravity.start();
  }
  
  let gyroscope = new Gyroscope();
  gyroscope.addEventListener('reading', e => rotationHandler({
    alpha: gyroscope.x,
    beta: gyroscope.y,
    gamma: gyroscope.z
  }));
  gyroscope.start();
  
} else if ('DeviceMotionEvent' in window) {
  document.getElementById('moApi').innerHTML = 'Device Motion API';
  
  var onDeviceMotion = function (eventData) {
    accelerationHandler(eventData.acceleration, 'moAccel');
    accelerationHandler(eventData.accelerationIncludingGravity, 'moAccelGrav');
    rotationHandler(eventData.rotationRate);
    intervalHandler(eventData.interval);
  }
  
  window.addEventListener('devicemotion', onDeviceMotion, false);
} else {
  document.getElementById('moApi').innerHTML = 'No Accelerometer & Gyroscope API available';
}

function accelerationHandler(acceleration, targetId) {
  var info, xyz = "[X, Y, Z]";

  info = xyz.replace("X", acceleration.x && acceleration.x.toFixed(3));
  info = info.replace("Y", acceleration.y && acceleration.y.toFixed(3));
  info = info.replace("Z", acceleration.z && acceleration.z.toFixed(3));
  document.getElementById(targetId).innerHTML = info;
}

function rotationHandler(rotation) {
  var info, xyz = "[X, Y, Z]";

  info = xyz.replace("X", rotation.alpha && rotation.alpha.toFixed(3));
  info = info.replace("Y", rotation.beta && rotation.beta.toFixed(3));
  info = info.replace("Z", rotation.gamma && rotation.gamma.toFixed(3));
  document.getElementById("moRotation").innerHTML = info;
}

function intervalHandler(interval) {
  document.getElementById("moInterval").innerHTML = interval;
}`,
        jsOnExit: `if (onDeviceMotion) {
    window.removeEventListener('devicemotion', onDeviceMotion);
}`
      },
      links: [
        {url: 'https://w3c.github.io/deviceorientation/spec-source-orientation.html#devicemotion', title: 'Device Orientation API Specification Draft'},
        {url: 'https://w3c.github.io/accelerometer/', title: 'Accelerometer API Specification Draft'},
        {url: 'https://w3c.github.io/gyroscope/', title: 'Gyroscope API Specification Draft'},
        {url: 'https://w3c.github.io/sensors/', title: 'Generic Sensor API Specification Draft'},
        {url: 'https://www.w3.org/TR/motion-sensors/', title: 'Motion Sensors Explainer'},
        {url: 'https://developers.google.com/web/updates/2017/09/sensors-for-the-web', title: 'Google Developers: Sensors For The Web'},
        {url: 'https://github.com/kenchris/sensor-polyfills', title: 'Polyfills for the W3C Generic Sensor APIs'}
      ]
    }),

    speech: new Feature({
      id: 'speech-recognition',
      name: 'Speech Recognition',
      description: [`The speech recognition part of the <b>Web Speech API</b> allows authorized Web applications to access the device's microphone
        and produces a transcript of the voice being recorded. This allows Web applications to use voice as one of the input & control method,
        similar to touch or keyboard.`,
        `Technically, the speech recognition functionality can also be achieved by <a href="/camera-microphone.html">accessing the microphone</a>
        and processing the audio stream using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API" target="_blank">Web Audio API</a>.
        An examplary library that takes such an approach is <a href="http://syl22-00.github.io/pocketsphinx.js/" target="_blank">pocketsphinx.js</a>.`],
      api: `<dl>
        <dt><code>let recognition = new SpeechRecognition()</code></dt>
        <dd>Creates an object used to configure the recognition process and to receive events about the recognition results.</dd>
        <dt><code>recognition.continuous</code></dt>
        <dd>A boolean property indicating whether the process should stop after the first final transcripts received (when <code>false</code>, the default)
          or send multiple events, until the process is explicitly stopped (when <code>true</code>).</dd>
        <dt><code>recognition.interimResults</code></dt>
        <dd>A boolean property indicating whether interim (not-yet-final) transcripts should be provided, <code>false</code> by default.</dd>
        <dt><code>recognition.lang</code></dt>
        <dd>A property to set up the language for the recognition.</dd>
        <dt><code>recognition.addEventListener('result', listener)</code></dt>
        <dd>An event fired when the process has produced the transcripts for the piece of audio recorded. The listener is called with an array of results,
          each containing a boolean <code>final</code> flag indicating whether the result might be updated in the future event (when <code>false</code>)
          or not and the collection of alternative transcripts, each with <code>transcript</code> itself and a <code>confidence</code> value.</dd>
        <dt><code>recognition.addEventListener('nomatch', listener)</code></dt>
        <dd>An event fired when the process has not produced any transcripts for the piece of audio recorded with the confidence exceeding the minimal
          threshold, i.e. it is not possible to provide the transcription.</dd>
        <dt><code>recognition.start()</code></dt>
        <dd>Starts the recognition process.</dd>
        <dt><code>recognition.stop()</code></dt>
        <dd>Stops the recognition process; useful when <code>recognition.continuous</code> is set to <code>true</code>.</dd>
      </dl>`,
      caniuse: 'speech-recognition',
      tests: [Feature.windowContains('SpeechRecognition')],
      links: [
        {url: 'https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html#speechreco-section', title: 'Specification'},
        {url: 'http://www.sitepoint.com/introducing-web-speech-api/', title: 'SitePoint: Introducing the Web Speech API'},
        {
          url: 'https://developers.google.com/web/updates/2013/01/Voice-Driven-Web-Apps-Introduction-to-the-Web-Speech-API',
          title: 'Voice Driven Web Apps: Introduction to the Web Speech API'
        },
        {url: 'https://shaungallagher.github.io/say_restyle/', title: 'Demo - Edit the webpage with your voice'}
      ]
    }),

    clipboard: new Feature({
      id: 'clipboard',
      name: 'Clipboard (Copy & Paste)',
      description: [`The <b>Clipboard API</b> gives Web applications a way to react on cut, copy and paste operations performed by the user as well as
        read from or write to the system clipboard directly on behalf of user.`,
        `There are two flavors of Clipboard API available - the older, synchronous, and the newer, asynchronous. The newer API is only available
        on HTTPS and require explicit <a href="/permissions.html">user permission</a>.`],
      api: `<p><b>Older, synchronous API</b></p>
      <dl>
        <dt><code>document.addEventListener('cut/copy/paste', listener)</code></dt>
        <dd>An event fired when the user invoked the particular clipboard operation (either cut, copy or paste).</dd>
        <dt><code>event.clipboardData.setData('text/plain', data)</code></dt>
        <dd>Sets the data that is to be written to the clipboard by the cut or copy operations in the specified format.</dd>
        <dt><code>event.clipboardData.getData('text/plain')</code></dt>
        <dd>Returns the data that has been read from the clipboard by the paste operation in the specified format.</dd>
        <dt><code>document.execCommand('cut/copy/paste')</code></dt>
        <dd>Programatically invokes the specified clipboard operation (either cut, copy or paste) on the data or element currently having a focus.</dd>
      </dl>
      <p><b>Newer, asynchronous API</b></p>
      <dl>
        <dt><code>navigator.clipboard.writeText(text)</code></dt>
        <dd>Writes the data to the clipboard. Returns a <code>Promise</code> resolved when the operation has succeeded.</dd>
        <dt><code>navigator.clipboard.readText()</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the data read from the clipboard.</dd>
      </dl>`,
      caniuse: 'clipboard',
      tests: [
        Feature.windowContains('ClipboardEvent'),
        Feature.containedIn('document', global.document, 'oncut'),
        Feature.containedIn('document', global.document, 'oncopy'),
        Feature.containedIn('document', global.document, 'onpaste'),
        Feature.navigatorContains('clipboard')
      ],
      demo: {
        html: `<p class="heading">Use the forms below for programmatic clipboard access or invoke standard copy/cut/paste operations with your keyboard.</p>
<section>
  <label><input type="radio" name="api" value="sync"> Use older, synchronous API</label><br/>
  <label><input type="radio" name="api" value="async" checked> Use newer, asynchronous API</label>
</section>
<section>
  <h2>Cut/Paste Example</h2>
  <p>
    <textarea class="js-cuttextarea form-control">Hello! Cut me programatically or maybe try pasting here.</textarea>
  </p>

  <p>
    <button class="js-textareacutbtn btn btn-default">Cut text programatically</button>
  </p>
</section>

<section>
  <h2>Copy Example</h2>
  <p>Email me at <a class="js-emaillink" href="mailto:matt@example.co.uk">matt@example.co.uk</a></p>
  <p>
    <button class="js-emailcopybtn btn btn-default">Copy Email Address programatically</button>
  </p>
</section>

<p id="logTarget"></p>

<p><small>Demo based on <a href="https://googlechrome.github.io/samples/cut-and-copy/index.html" target="_blank">Google Chrome examples</a>.</small></p>`,
        js: `var logTarget = document.getElementById('logTarget');

function useAsyncApi() {
  return document.querySelector('input[value=async]').checked;
}

function log(event) {
  var timeBadge = new Date().toTimeString().split(' ')[0];
  var newInfo = document.createElement('p');
  newInfo.innerHTML = '<span class="badge">' + timeBadge + '</span> ' + event + '</b>.';
  logTarget.appendChild(newInfo);
}

function performCopyEmail() {
  var selection = window.getSelection();
  var emailLink = document.querySelector('.js-emaillink');

  if (useAsyncApi()) {
    navigator.clipboard.writeText(emailLink.textContent)
      .then(() => log('Async writeText successful, "' + emailLink.textContent + '" written'))
      .catch(err => log('Async writeText failed with error: "' + err + '"'));
  } else {
    selection.removeAllRanges();
    var range = document.createRange();
    range.selectNode(emailLink);
    selection.addRange(range);
  
    try {
      var successful = document.execCommand('copy');
      var msg = successful ? 'successful' : 'unsuccessful';
      log('Copy email command was ' + msg);
    } catch (err) {
      log('execCommand Error', err);
    }
    
    selection.removeAllRanges();
  }
}

function performCutTextarea() {
  var cutTextarea = document.querySelector('.js-cuttextarea');

  if (useAsyncApi()) {
    navigator.clipboard.writeText(cutTextarea.textContent)
      .then(() => {
        log('Async writeText successful, "' + cutTextarea.textContent + '" written');
        cutTextarea.textContent = '';
      })
      .catch(err => log('Async writeText failed with error: "' + err + '"'));
  } else {
    var hasSelection = document.queryCommandEnabled('cut');
    cutTextarea.select();
  
    try {
      var successful = document.execCommand('cut');
      var msg = successful ? 'successful' : 'unsuccessful';
      log('Cutting text command was ' + msg);
    } catch (err) {
      log('execCommand Error', err);
    }
  }
}

// Get the buttons
var cutTextareaBtn = document.querySelector('.js-textareacutbtn');
var copyEmailBtn = document.querySelector('.js-emailcopybtn');

// Add click event listeners
copyEmailBtn.addEventListener('click', performCopyEmail);
cutTextareaBtn.addEventListener('click', performCutTextarea);

function logUserOperation(event) {
  log('User performed <b>' + event.type + '</b> operation. Payload is: <b>' + event.clipboardData.getData('text/plain') + '</b>');
}

document.addEventListener('cut', logUserOperation);
document.addEventListener('copy', logUserOperation);
document.addEventListener('paste', logUserOperation);`,
        jsOnExit: `document.removeEventListener('cut', logUserOperation);
document.removeEventListener('copy', logUserOperation);
document.removeEventListener('paste', logUserOperation);`
      },
      links: [
        {url: 'https://w3c.github.io/clipboard-apis/', title: 'Specification Draft'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/ClipboardEvent', title: 'MDN: ClipboardEvent'},
        {
          url: 'https://www.lucidchart.com/techblog/2014/12/02/definitive-guide-copying-pasting-javascript/',
          title: 'The Definitive Guide to Copying and Pasting in JavaScript'
        },
        {url: 'https://developers.google.com/web/updates/2018/03/clipboardapi', title: 'Unblocking Clipboard Access'}
      ]
    }),

    pointerAdaptation: new Feature({
      id: 'pointer-adaptation',
      name: 'Pointing Device Adaptation',
      description: [`The <b>Interaction Media</b> part of CSS4 specification defines the media queries allowing Web applications to alter its layout
        and user interface depending on the way the user is supposed to interact with the application. It allows to identify the browser's primary
        pointer (i.e. mouse, touch, keyboard) and decides whether it is fine or coarse and whether hovering over the element is possible using
        the "classic" interface (like touch on tablet), so that the interface might be shrunk or enlarged and hover interactions enabled
        or replaced with an alternative accordingly.`,
        `Additionally, the specification defines the similar media queries for cases when all the pointing methods (not only the primary one)
        should be considered - i.e. to answer the question is hovering possible at all, using any method available.`],
      api: `<dl class="language-css">
        <dt><code>@media (pointer: fine)</code></dt>
        <dd>The media query that limits the enclosed CSS rules to be used only when the primary pointing device allows accurate pointing.</dd>
        <dt><code>@media (pointer: coarse)</code></dt>
        <dd>The media query that limits the enclosed CSS rules to be used only when the primary pointing device does not allow accurate pointing.</dd>
        <dt><code>@media (pointer: none)</code></dt>
        <dd>The media query that limits the enclosed CSS rules to be used only when the primary interacting device is not capable of pointing
          (i.e. keyboard).</dd>
        <dt><code>@media (hover)</code></dt>
        <dd>The media query that limits the enclosed CSS rules to be used only when the primary pointing device allows hovering over elements.</dd>
        <dt><code>@media (any-pointer: fine)</code></dt>
        <dd>The media query that limits the enclosed CSS rules to be used only when any of the pointing devices available allows accurate pointing.</dd>
        <dt><code>@media (any-pointer: coarse)</code></dt>
        <dd>The media query that limits the enclosed CSS rules to be used only when any of the pointing devices does not allow accurate pointing.</dd>
        <dt><code>@media (any-hover)</code></dt>
        <dd>The media query that limits the enclosed CSS rules to be used only when any of the pointing devices allows hovering over elements.</dd>
      </dl>`,
      caniuse: 'css-media-interaction',
      tests: [
        Feature.rawTest('window', `matchMedia('(pointer: none), (pointer: coarse), (pointer: fine)').matches`, () => global.matchMedia && global.matchMedia('(pointer: none), (pointer: coarse), (pointer: fine)').matches)
      ],
      demo: {
        html: `<p>The button is larger when the primary pointer is coarse. The tooltip is visible on hover when the pointer allows hovering.</p>

<div class="text-center">
  <button id="button" class="btn btn-default">The button</button>
  <div id="tooltip" class="tooltip bottom" role="tooltip">
    <div class="tooltip-arrow"></div>
    <div class="tooltip-inner">
      Tooltip visible on hover when pointer allows hover
    </div>
  </div>
</div>`,
        css: `@media (hover: hover) {
  #tooltip {
    display: none;
  }
  #button:hover ~ #tooltip {
    display: block;
  }
}

@media (pointer: fine) {
  #button {
    font-size: x-small;
  }
}
@media (pointer: coarse) {
  #button {
    font-size: x-large;
  }
}`,
        cssHidden: `p, button {
  margin: 10px;
}
#tooltip {
  position: relative;
  opacity: 1;
}
#tooltip .tooltip-inner {
  margin: 0 auto;
}`
      },
      links: [
        {url: 'http://www.w3.org/TR/mediaqueries-4/#mf-interaction', title: 'Specification Draft'},
        {
          url: 'http://jordanm.co.uk/2013/11/11/potential-use-cases-for-script-hover-and-pointer.html',
          title: 'Potential use cases for script, hover and pointer CSS Level 4 Media Features'
        },
        {
          url: 'https://dev.opera.com/articles/media-features/',
          title: 'Dev.Opera: Interaction Media Features and their potential (for incorrect assumptions)'
        },
        {url: 'https://github.com/twbs/mq4-hover-shim', title: 'A shim for the Media Queries Level 4 `hover` media feature'},
        {url: 'http://radar.oreilly.com/2015/08/proposing-css-input-modailty.html', title: 'Proposing CSS input modality'}
      ]
    }),

    devicePosition: new Feature({
      id: 'device-position',
      aliases: ['device-orientation'],
      name: 'Device Position',
      description: [`The first-generation device position support is a part of <b>Device Orientation API</b>. It allows Web applications to access the gyroscope and compass data in order to determine the static orientation
        of the user's device in all the three dimensions, expressed in degrees of divergence from the "natural" northbound lie flat position.`,
        `The newer specification based on the <strong>Generic Sensor API</strong> also exists - the Orientation Sensor APIs (in absolute and relative variants). 
          Contrary to the previous specification it provides readings expressed as <a href="https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation" target="_blank">quaternions</a> what makes it directly compatible with drawing environments like WebGL.`,
        `For the detection of the device's movements, see <a href="/device-motion.html">Device Motion</a>.`],
      api: `<p><b>As a part of Device Orientation API</b></p>
      <dl>
        <dt><code>window.addEventListener('deviceorientation', listener)</code></dt>
        <dd>An event fired when the significant changes in the device's orientation has occured.</dd>
        <dt><code>event.alpha</code></dt>
        <dd>Returns device's current heading (direction) in degrees, counted counterclockwise from the North (0) through West (90), South (180) and East (270).</dd>
        <dt><code>event.beta</code></dt>
        <dd>Returns device's current front/back tilt in degrees, 0 when lying horizontally upward facing, 90 when in vertical position,
          -90 in vertical upside down, -180 when horizontal upside down.</dd>
        <dt><code>event.gamma</code></dt>
        <dd>Returns device's current left/right tilt in degrees, from -90 when turned left to 90 when turned right.</dd>
      </dl>
      <p><b>Absolute Orientation Sensor API</b></p>
      <dl>
        <dt><code>sensor = new AbsoluteOrientationSensor()</code></dt>
        <dd>Creates an object serving as an accessor to the orientation readings in relation to the Earth’s reference coordinate system, based on accelerometer, gyroscope and magenetometer readings.</dd>
        <dt><code>sensor.addEventListener('reading', listener)</code></dt>
        <dd>An event fired when the orientation reading has changed, indicating that the sensor object contains updated quaternion representing the device's orientation.</dd>
        <dt><code>sensor.start()</code></dt>
        <dd>Starts listening for the sensor readings.</dd>
        <dt><code>sensor.quaternion</code></dt>
        <dd>Returns the last available reading expressed as quaternion representing the device's orientation.</dd>
      </dl>
      <p><b>Relative Orientation Sensor API</b></p>
      <dl>
        <dt><code>sensor = new RelativeOrientationSensor()</code></dt>
        <dd>Creates an object serving as an accessor to the orientation readings in relation to a stationary reference coordinate system, based on accelerometer and gyroscope readings.</dd>
        <dt><code>sensor.addEventListener('reading', listener)</code></dt>
        <dd>An event fired when the orientation reading has changed, indicating that the sensor object contains updated quaternion representing the device's orientation.</dd>
        <dt><code>sensor.start()</code></dt>
        <dd>Starts listening for the sensor readings.</dd>
        <dt><code>sensor.quaternion</code></dt>
        <dd>Returns the last available reading expressed as quaternion representing the device's orientation.</dd>
      </dl>`,
      caniuse: 'deviceorientation',
      demo: {
        html: `<table class="table table-striped table-bordered">
  <tr>
    <td>Tilt Left/Right [gamma]</td>
    <td id="doTiltLR"></td>
  </tr>
  <tr>
    <td>Tilt Front/Back [beta]</td>
    <td id="doTiltFB"></td>
  </tr>
  <tr>
    <td>Direction [alpha]</td>
    <td id="doDirection"></td>
  </tr>
</table>

<div class="container" id="logoContainer">
  <img src="https://www.w3.org/html/logo/downloads/HTML5_Badge_512.png" id="imgLogo">
</div>

<p><small>Demo from <a href="https://www.html5rocks.com/en/tutorials/device/orientation/" target="_blank">HTML5 Rocks</a> article.</small></p>`,
        css: `.container {
  perspective: 300;
  -webkit-perspective: 300;
}

#imgLogo {
  width: 275px;
  margin-left: auto;
  margin-right: auto;
  display: block;
  padding: 15px;
}`,
        js: `if ('DeviceOrientationEvent' in window) {
  window.addEventListener('deviceorientation', deviceOrientationHandler, false);
} else {
  document.getElementById('logoContainer').innerText = 'Device Orientation API not supported.';
}

function deviceOrientationHandler (eventData) {
  var tiltLR = eventData.gamma;
  var tiltFB = eventData.beta;
  var dir = eventData.alpha;
  
  document.getElementById("doTiltLR").innerHTML = Math.round(tiltLR);
  document.getElementById("doTiltFB").innerHTML = Math.round(tiltFB);
  document.getElementById("doDirection").innerHTML = Math.round(dir);

  var logo = document.getElementById("imgLogo");
  logo.style.webkitTransform = "rotate(" + tiltLR + "deg) rotate3d(1,0,0, " + (tiltFB * -1) + "deg)";
  logo.style.MozTransform = "rotate(" + tiltLR + "deg)";
  logo.style.transform = "rotate(" + tiltLR + "deg) rotate3d(1,0,0, " + (tiltFB * -1) + "deg)";
}`,
        jsOnExit: `window.removeEventListener('deviceorientation', deviceOrientationHandler);`
      },
      tests: [
        Feature.windowContains('DeviceOrientationEvent'),
        Feature.windowContains('AbsoluteOrientationSensor'),
        Feature.windowContains('RelativeOrientationSensor')
      ],
      links: [
        {url: 'https://w3c.github.io/deviceorientation/spec-source-orientation.html', title: 'Older Device Orientation API Specification Draft'},
        {url: 'https://www.w3.org/TR/orientation-sensor/', title: 'Orientation Sensors specification draft'},
        {url: 'https://www.w3.org/TR/motion-sensors/', title: 'Motion Sensors Explainer'},
        {url: 'https://developers.google.com/web/updates/2017/09/sensors-for-the-web', title: 'Google Developers: Sensors For The Web'},
        {url: 'https://github.com/kenchris/sensor-polyfills', title: 'Polyfills for the W3C Generic Sensor APIs'}
      ]
    }),

    fullScreen: new Feature({
      id: 'fullscreen',
      name: 'Fullscreen',
      description: `The <b>Fullscreen API</b> allows Web applications to present itself or the part of itself in the fullscreen mode,
        without browser UI elements visible. It also serves as the prerequisite state for the <a href="/orientation-lock.html">orientation lock</a>.`,
      api: `<dl>
        <dt><code>document.fullscreenEnabled</code></dt>
        <dd>Returns a boolean indicating whether the fullscreen mode is available and allowed.</dd>
        <dt><code>element.requestFullscreen()</code></dt>
        <dd>Requests a fullscreen mode display for a given <code>element</code>. Returns a <code>Promise</code> resolved when the request was successful.</dd>
        <dt><code>document.fullscreenElement</code></dt>
        <dd>Returns a reference to the element currently being displayed in the fullscreen mode.</dd>
        <dt><code>document.exitFullscreen()</code></dt>
        <dd>Exits the fullscreen mode.</dd>
        <dt><code>document.addEventListener('fullscreenchange', listener)</code></dt>
        <dd>An event fired when the fullscreen mode has been entered or exited.</dd>
      </dl>`,
      caniuse: 'fullscreen',
      demo: {
        html: `<p>
  <button class="btn btn-default start" id="startFull">Start fullscreen on the whole page</button>
  <button class="btn btn-default" id="exit">Exit fullscreen</button>
</p>

<div>
  <button class="btn btn-default start" id="startBox">Start fullscreen on just the green box</button>
  <div id="box">THE BOX</div>
</div>

<p id="logTarget"></p>`,
        css: `#box {
  width: 90px;
  height: 20px;
  background-color: green;
  color: white;
  text-align: center;
  display: inline-block;
  border-radius: 5px;
}

#exit {
  display: none;
}`,
        js: `var $ = document.querySelector.bind(document);
var $$ = function (selector) {
  return [].slice.call(document.querySelectorAll(selector), 0);
}
var target = $('#logTarget');

function logChange (event) {
  var timeBadge = new Date().toTimeString().split(' ')[0];
  var newState = document.createElement('p');
  newState.innerHTML = '<span class="badge">' + timeBadge + '</span> ' + event + '.';
  target.appendChild(newState);
}

var prefix = null;
if ('requestFullscreen' in document.documentElement) {
  prefix = 'fullscreen';
} else if ('mozRequestFullScreen' in document.documentElement) {
  prefix = 'mozFullScreen';
} else if ('webkitRequestFullscreen' in document.documentElement) {
  prefix = 'webkitFullscreen';
} else if ('msRequestFullscreen') {
  prefix = 'msFullscreen';
}

var onFullscreenChange = function () {
  var elementName = 'not set';
  if (document[prefix + 'Element']) {
    elementName = document[prefix + 'Element'].nodeName;
  }
  logChange('New fullscreen element is <b>' + elementName + '</b>');
  onFullscreenHandler(!!document[prefix + 'Element']);
}

if (document[prefix + 'Enabled']) {
  var onFullscreenHandler = function (started) {
    $('#exit').style.display = started ? 'inline-block' : 'none';
    $$('.start').forEach(function (x) {
      x.style.display = started ? 'none' : 'inline-block';
    });
  };

  document.addEventListener(prefix.toLowerCase() + 'change', onFullscreenChange);

  var goFullScreen = null;
  var exitFullScreen = null;
  if ('requestFullscreen' in document.documentElement) {
    goFullScreen = 'requestFullscreen';
    exitFullScreen = 'exitFullscreen';
  } else if ('mozRequestFullScreen' in document.documentElement) {
    goFullScreen = 'mozRequestFullScreen';
    exitFullScreen = 'mozCancelFullScreen';
  } else if ('webkitRequestFullscreen' in document.documentElement) {
    goFullScreen = 'webkitRequestFullscreen';
    exitFullScreen = 'webkitExitFullscreen';
  } else if ('msRequestFullscreen') {
    goFullScreen = 'msRequestFullscreen';
    exitFullScreen = 'msExitFullscreen';
  }

  var goFullscreenHandler = function (element) {
    return function () {
      var maybePromise = element[goFullScreen]();
      if (maybePromise && maybePromise.catch) {
        maybePromise.catch(function (err) {
          logChange('Cannot acquire fullscreen mode: ' + err);
        });
      }
    };
  };

  $('#startFull').addEventListener('click', goFullscreenHandler(document.documentElement));
  $('#startBox').addEventListener('click', goFullscreenHandler($('#box')));

  $('#exit').addEventListener('click', function () {
    document[exitFullScreen]();
  });
}`,
        jsOnExit: `document.removeEventListener(prefix.toLowerCase() + 'change', onFullscreenChange);`
      },
      tests: [
        Feature.containedIn('document.documentElement', global.document && document.documentElement, 'requestFullScreen'),
        Feature.containedIn('document.documentElement', global.document && document.documentElement, 'requestFullscreen')
      ],
      links: [
        {url: 'https://fullscreen.spec.whatwg.org/', title: 'Specification'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API', title: 'MDN: Fullscreen API'},
        {
          url: 'https://hacks.mozilla.org/2012/01/using-the-fullscreen-api-in-web-browsers/',
          title: 'Mozilla Hacks: Using the Fullscreen API in Web browsers'
        }
      ]
    }),

    screenOrientation: new Feature({
      id: 'screen-orientation',
      aliases: ['orientation-lock'],
      name: 'Screen Orientation & Lock',
      description: [`The <b>Screen Orientation API</b> allows Web applications to get the information about the current orientation of the document
        (portrait or landscape) as well as to lock the screen orientation in a requested state.`,
        `The current version of the specification defines this feature fully within <code>window.screen.orientation</code> object. The previous version,
        still available in Microsoft Edge as of June 2017, separated the orientation lock to <code>window.screen.lockOrientation</code>.`
      ],
      api: `<dl>
        <dt><code>window.screen.orientation.type</code></dt>
        <dd>Returns the current screen orientation type as one of <code>portrait-primary</code>, <code>portrait-secondary</code> (upside down),
          <code>landscape-primary</code> and <code>landscape-secondary</code> (upside down).</dd>
        <dt><code>window.screen.orientation.addEventListener('change', listener)</code></dt>
        <dd>An event fired when the document orientation has changed.</dd>
        <dt><code>window.screen.orientation.lock(lockType)</code></dt>
        <dd>Requests a screen lock in the <code>lockType</code> specified. Returns a <code>Promise</code> resolved when the lock was acquired successfully.</dd>
        <dt><code>window.screen.orientation.unlock()</code></dt>
        <dd>Removes previously acquired screen orientation lock.</dd>
      </dl>`,
      caniuse: 'screen-orientation',
      demo: {
        html: `<div id="device"></div>

<p>Current screen orientation is <b id="orientationType">unknown</b>.</p>

<p>
  <button class="btn btn-default" id="lock">Lock in current orientation</button>
  <button class="btn btn-default" id="unlock">Release the lock</button>
</p>

<p id="logTarget"></p>`,
        css: `#device {
  margin: 10px;
  border: 1px solid black;
  border-radius: 10px;
}

#device:after {
  content: 'A';
  font: 80px serif;
  display: block;
  text-align: center;
}

#unlock {
  display: none;
}`,
        js: `var $ = document.getElementById.bind(document);

var orientKey = 'orientation';
if ('mozOrientation' in screen) {
  orientKey = 'mozOrientation';
} else if ('msOrientation' in screen) {
  orientKey = 'msOrientation';
}

var target = $('logTarget');
var device = $('device');
var orientationTypeLabel = $('orientationType');

function logChange (event) {
  var timeBadge = new Date().toTimeString().split(' ')[0];
  var newState = document.createElement('p');
  newState.innerHTML = '<span class="badge">' + timeBadge + '</span> ' + event + '.';
  target.appendChild(newState);
}

if (screen[orientKey]) {
  function update() {
    var type = screen[orientKey].type || screen[orientKey];
    orientationTypeLabel.innerHTML = type;

    var landscape = type.indexOf('landscape') !== -1;

    if (landscape) {
      device.style.width = '180px';
      device.style.height = '100px';
    } else {
      device.style.width = '100px';
      device.style.height = '180px';
    }

    var rotate = type.indexOf('secondary') === -1 ? 0 : 180;
    var rotateStr = 'rotate(' + rotate + 'deg)';

    device.style.webkitTransform = rotateStr;
    device.style.MozTransform = rotateStr;
    device.style.transform = rotateStr;
  }

  update();

  var onOrientationChange = null;

  if ('onchange' in screen[orientKey]) { // newer API
    onOrientationChange = function () {
      logChange('Orientation changed to <b>' + screen[orientKey].type + '</b>');
      update();
    };
  
    screen[orientKey].addEventListener('change', onOrientationChange);
  } else if ('onorientationchange' in screen) { // older API
    onOrientationChange = function () {
      logChange('Orientation changed to <b>' + screen[orientKey] + '</b>');
      update();
    };
  
    screen.addEventListener('orientationchange', onOrientationChange);
  }

  // browsers require full screen mode in order to obtain the orientation lock
  var goFullScreen = null;
  var exitFullScreen = null;
  if ('requestFullscreen' in document.documentElement) {
    goFullScreen = 'requestFullscreen';
    exitFullScreen = 'exitFullscreen';
  } else if ('mozRequestFullScreen' in document.documentElement) {
    goFullScreen = 'mozRequestFullScreen';
    exitFullScreen = 'mozCancelFullScreen';
  } else if ('webkitRequestFullscreen' in document.documentElement) {
    goFullScreen = 'webkitRequestFullscreen';
    exitFullScreen = 'webkitExitFullscreen';
  } else if ('msRequestFullscreen') {
    goFullScreen = 'msRequestFullscreen';
    exitFullScreen = 'msExitFullscreen';
  }

  $('lock').addEventListener('click', function () {
    document.documentElement[goFullScreen] && document.documentElement[goFullScreen]();

    var promise = null;
    if (screen[orientKey].lock) {
      promise = screen[orientKey].lock(screen[orientKey].type);
    } else {
      promise = screen.orientationLock(screen[orientKey]);
    }

    promise
      .then(function () {
        logChange('Screen lock acquired');
        $('unlock').style.display = 'block';
        $('lock').style.display = 'none';
      })
      .catch(function (err) {
        logChange('Cannot acquire orientation lock: ' + err);
        document[exitFullScreen] && document[exitFullScreen]();
      });
  });

  $('unlock').addEventListener('click', function () {
    document[exitFullScreen] && document[exitFullScreen]();

    if (screen[orientKey].unlock) {
      screen[orientKey].unlock();
    } else {
      screen.orientationUnlock();
    }

    logChange('Screen lock removed.');
    $('unlock').style.display = 'none';
    $('lock').style.display = 'block';
  });
}`,
        jsOnExit: `if ('onchange' in screen[orientKey]) { // newer API
    screen[orientKey].removeEventListener('change', onOrientationChange);
  } else if ('onorientationchange' in screen) { // older API
    screen.removeEventListener('orientationchange', onOrientationChange);
  }`
      },
      tests: [
        Feature.containedIn('screen', global.screen, 'orientation'),
        Feature.containedIn('screen', global.screen, 'lockOrientation', false)
      ],
      links: [
        {url: 'https://w3c.github.io/screen-orientation/', title: 'Specification Draft'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation', title: 'MDN: Screen.orientation'},
        {url: 'http://www.sitepoint.com/introducing-screen-orientation-api/', title: 'SitePoint: Introducing the Screen Orientation API'}
      ]
    }),

    wakeLock: new Feature({
      id: 'wake-lock',
      name: 'Wake Lock',
      description: [`The <b>Wake Lock API</b> allows Web applications to prevent the resource such as the screen or system from becoming
        unavailable as long as the application holds a lock for that resource. The purpose of the API is to let the user or the application to complete
        the ongoing long activity - like navigation or reading - uninterrupted.`,
        `The only available implementation, available behind an "Experimental Web Platform Features" flag in Google Chrome on desktop, is just a boolean flag controllable by the application, 
        based on the previous version of the specification. It is now considered too open for abuse and is lacking user consent, so the recent specification draft
        (published June 2017) proposes more explicit approach. It is not implemented by any vendor, yet.`],
      api: `<p><b>Newer specification</b></p>
      <dl>
        <dt><code>navigator.getWakeLock('screen')</code></dt>
        <dd>Requests a wake lock managing object on the resource specified, such as <code>screen</code> or <code>system</code>. 
        Returns a <code>Promise</code> with the lock managing object.</dd>
        <dt><code>lockRequest = lock.createRequest()</code></dt>
        <dd>Activates the wake lock on the previously acquired managing object.</dd>
        <dt><code>lockRequest.cancel()</code></dt>
        <dd>Releases the existing lock.</dd>
      </dl>
      <p><b>Older specification</b></p>
      <dl>
        <dt><code>screen.keepAwake = true</code></dt>
        <dd>The property allowing to acquire a screen wake lock when set to <code>true</code> and release it when set to <code>false</code>.</dd>
      </dl>`,
      demo: {
        html: `<p>Wake Lock status is <b id="status">unknown (not supported)</b>.</p>
<p><button class="btn btn-default" onclick="toggle()">Toggle</button></p>`,
        js: `function printStatus() {
  document.getElementById("status").innerHTML = screen.keepAwake
    ? "enabled"
    : "disabled";
}

function toggle() {
  if ("keepAwake" in screen) {
    screen.keepAwake = !screen.keepAwake;
    printStatus();
  }
}

if ("keepAwake" in screen) {
  printStatus();
}`
      },
      tests: [
        Feature.containedIn('screen', global.screen, 'keepAwake'),
        Feature.navigatorContains('getWakeLock')
      ],
      links: [
        {url: 'https://w3c.github.io/wake-lock/', title: 'W3C Specification Draft'}
      ]
    }),

    photos: new Feature({
      id: 'photos',
      name: 'Advanced Camera Controls',
      description: [`The <b>Image Capture API</b> allows Web applications to control the advanced settings of the device's camera, such as zoom, white balance, ISO or focus points and take photos based on these settings. It relies on the <code>streamVideoTrack</code> object that might be obtained from the <code>stream</code> - see <a href="/camera-microphone.html">Audio & Video Capture</a>.`],
      api: `<dl>
        <dt><code>capturer = ImageCapture(streamVideoTrack)</code></dt>
        <dd>Creates an image capturer out of the Media Stream Video Track.</dd>
        <dt><code>capturer.takePhoto()</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the photo taken with the current settings.</dd>
        <dt><code>capturer.setOptions(photoSettings)</code></dt>
        <dd>Configures the <code>photoSettings</code> for subsequent captures; if visible, the effects of the configuration can be seen in the Track used as input.</dd>
      </dl>`,
      tests: [Feature.windowContains('ImageCapture')],
      demo: {
        html: `<p><button class="btn btn-lg btn-default" onclick="getStream()">Grab video</button></p>
<p><video autoplay style="height: 180px; width: 240px;"></video></p>
<p><button class="btn btn-lg btn-default" onclick="takePhoto()">Take Photo!</button></p>
<p><img id="imageTag" width="240" height="180"></p>

<p><small>Demo by <a href="http://www.mcasas.tk/" target="_blank">Miguel Casas-Sanchez</a>.</small></p>`,
        js: `function getUserMedia(options, successCallback, failureCallback) {
  var api = navigator.getUserMedia || navigator.webkitGetUserMedia ||
    navigator.mozGetUserMedia || navigator.msGetUserMedia;
  if (api) {
    return api.bind(navigator)(options, successCallback, failureCallback);
  }
}

var theStream;

function getStream() {
  if (!navigator.getUserMedia && !navigator.webkitGetUserMedia &&
    !navigator.mozGetUserMedia && !navigator.msGetUserMedia) {
    alert('User Media API not supported.');
    return;
  }
  
  var constraints = {
    video: true
  };

  getUserMedia(constraints, function (stream) {
    var mediaControl = document.querySelector('video');
    if ('srcObject' in mediaControl) {
      mediaControl.srcObject = stream;
    } else if (navigator.mozGetUserMedia) {
      mediaControl.mozSrcObject = stream;
    } else {
      mediaControl.src = (window.URL || window.webkitURL).createObjectURL(stream);
    }
    theStream = stream;
  }, function (err) {
    alert('Error: ' + err);
  });
}

function takePhoto() {
  if (!('ImageCapture' in window)) {
    alert('ImageCapture is not available');
    return;
  }
  
  if (!theStream) {
    alert('Grab the video stream first!');
    return;
  }
  
  var theImageCapturer = new ImageCapture(theStream.getVideoTracks()[0]);

  theImageCapturer.takePhoto()
    .then(blob => {
      var theImageTag = document.getElementById("imageTag");
      theImageTag.src = URL.createObjectURL(blob);
    })
    .catch(err => alert('Error: ' + err));
}`
      },
      links: [
        {url: 'https://w3c.github.io/mediacapture-image/', title: 'W3C Specification Draft'},
        {url: 'https://developers.google.com/web/updates/2016/12/imagecapture', title: 'Google Developers: Take Photos and Control Camera Settings'},
        {url: 'https://rawgit.com/Miguelao/demos/master/imagecapture.html', title: 'Demo'}
      ]
    }),

    presentation: new Feature({
      id: 'presentation',
      name: 'Presentation Features',
      description: [`The <b>Presentation API</b> aims at allowing Web applications to use the presentation display mode. The display used to present
        may be the same that the browser is using, but may also be the external display device. The browser might serve as the initiator
        of the presentation as well as receive the connections to the presentations initiated externally on the presentation display.`,
        `The API at the moment is supported only in Chrome and Opera, on desktop and on Android.`],
      api: `<dl>
        <dt><code>navigator.presentation.defaultRequest = new PresentationRequest(presentationUrl)</code></dt>
        <dd>Sets up an object representing the browser's request for initiating the specified presentation on a presentation display.</dd>
        <dt><code>request.getAvailability()</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the object providing availability of a presentation display.</dd>
        <dt><code>availability.value</code></dt>
        <dd>Returns a boolean indicating whether a presentation display is available.</dd>
        <dt><code>availability.addEventListener('change', listener)</code></dt>
        <dd>An event fired when the availability status of a presentation display has changed.</dd>
        <dt><code>request.start()</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the connection to the newly initiated presentation on the presentation display.</dd>
        <dt><code>connection.state</code></dt>
        <dd>Returns a string indicating the state of the presentation on the presentation display, i.e. <code>connected</code>, <code>closed</code>, <code>terminated</code>.</dd>
        <dt><code>connection.addEventListener('statechange', listener)</code></dt>
        <dd>An event fired when the state of the presentation on the presentation display has changed.</dd>
        <dt><code>connection.send(message)</code></dt>
        <dd>Sends a message to the presentation running on the presentation display.</dd>
        <dt><code>connection.addEventListener('message', listener)</code></dt>
        <dd>An event fired when a message from the presentation running on the presentation display has been received.</dd>
        <dt><code>connection.close()</code></dt>
        <dd>Closes the connection to the presentation running on the presentation display, letting it continue uninterrupted.</dd>
        <dt><code>connection.terminate()</code></dt>
        <dd>Terminates the presentation running on the presentation display.</dd>
        <dt><code>navigator.presentation.receiver.getConnections()</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the array of connections to the presentations running on a presentation display.</dd>
        <dt><code>navigator.presentation.receiver.addEventListener('connectionavailable', listener)</code></dt>
        <dd>An event fired when the new connection to the presentations running on a presentation display has become available.</dd>
      </dl>`,
      tests: [
        Feature.navigatorContains('presentation'),
        Feature.windowContains('PresentationRequest')
      ],
      links: [
        {url: 'https://w3c.github.io/presentation-api/', title: 'Specification Draft'},
        {url: 'https://www.w3.org/community/webscreens/presentation-api-demos/', title: 'Presentation API demos'},
        {
          url: 'https://developers.google.com/web/updates/2015/11/presentation-api?hl=en',
          title: 'Google Cast for Chrome on Android - using Presentation API underneath'
        }
      ]
    }),

    backgroundSync: new Feature({
      id: 'background-sync',
      name: 'Background Sync',
      description: [`The <b>Background Sync API</b> allows authorized Web applications to not rely on having stable internet connection 
        and defer network-related operations to the moment the connection is available. The API is bound to the Service Worker, which is 
        the code execution model that is separated from the owning Web application. This allows the Background Sync to operate also after 
        the application window was closed.`,
        `The API itself is only a way of signaling the application about the restored connectivity. It might be used together with any
        <a href="storage.html">Offline Storage</a> solution to implement a data synchronization scheme or a replay mechanism for 
        the network requests issued when the application was offline`,
        `The specification previously planned the second mode of operation - as a periodic sync, useful for automatic data synchronization 
        from the internet - but this mode was dropped before it was implemented by any browser vendor.`,
         `As of December 2017, the API is only implemented in Google Chrome.`],
      api: `<dl>
        <dt><code>serviceWorkerRegistration.sync.register('syncTag')</code></dt>
        <dd>Requests an one-off sync registration. Returns a <code>Promise</code> when the request has been registered.</dd>
        <dt><code>self.addEventListener('sync', listener)</code></dt>
        <dd>An event fired within the Service Worker instance when there is a connection available and the synchronization is possible. The <code>listener</code> is expected to call <code>event.waitUntil(promise)</code> specifying a <code>Promise</code> that resolves when the sync handling has been completed.</dd>
      </dl>`,
      tests: [Feature.windowContains('SyncManager')],
      caniuse: 'background-sync',
      links: [
        {url: 'https://wicg.github.io/BackgroundSync/spec/', title: 'Specification Draft (non-W3C)'},
        {url: 'https://developers.google.com/web/updates/2015/12/background-sync', title: 'Google Developers: Introducing Background Sync'}
      ]
    }),

    intents: new Feature({
      id: 'app-communication',
      name: 'Inter-App Communication',
      description: [`There were several attempts to establish the universal, multi-platform, asynchronous way of data exchange from the Web applications to native apps or another Web apps and up to date no standardized solution was concieved.`,
        `There are, however, some basic workarounds for sending data to another applications. Native applications can register handlers to receive data from the Web apps using special URL prefixes (although differences exist between <a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6-SW1" target="_blank">iOS</a> and <a href="https://developer.android.com/training/app-links/index.html" target="_blank">Android</a>). There are also third-party non-standard services that coordinate sharing data between Web applications.`,
        `Google Chrome 18 implemented the <b>Web Intents</b> experimental API. It was conceptually based on <a href="https://developer.android.com/guide/components/intents-filters.html" target="_blank">Android Intents</a> system. The apps interested in receiving data were required to be registered in Chrome Web Store and declare the intent support in the manifest file. The apps sending the data were able to invoke the Intent of the particular type and let the system handle the selection of the target application and its proper invocation. The API was removed in Chrome 24 because of various interoperability and usability issues. No other vendor implemented Web Intents.`,
        `The newest implementation, <b>Web Share API</b>, as of September 2017 available in Chrome on Android, is much simpler and consists of a method to invoke the platform-specific share mechanism and is limited to sharing named URLs only. There is a complementary <b>Web Share Target API</b> <a href="https://github.com/WICG/web-share-target" target="_blank">in an early design phase</a> to allow registering Web applications as the share receivers.`],
      api: `<p><b>Web Intents API</b></p>
      <dl>
        <dt><code>intent = new Intent(action, type, href)</code></dt>
        <dd>Creates an object representing the request for a particular action (command) to be sent to the registered handling applications.</dd>
        <dt><code>navigator.startActivity(intent, onSuccess, onFailure)</code></dt>
        <dd>Invokes the system-defined application selection and data share dialog to send the request to another application.</dd>
        <dt><code>window.intent.postResult(result)</code></dt>
        <dd>Sends the <code>result</code> from the requested (target) application back to the requesting (source) application.</dd>
      </dl>
      <p><b>Web Share API</b></p>
      <dl>
        <dt><code>navigator.share({name, title, url})</code></dt>
        <dd>Invokes the system-defined application selection and data share dialog to send the named URL to another application and returns a <code>Promise</code> resolved when the share was successful.</dd>
      </dl>`,
      tests: [
        Feature.windowContains('Intent', false),
        Feature.navigatorContains('share')
      ],
      caniuse: 'web-share',
      demo: {
        html: `<p>
  <button class="btn btn-lg btn-default" onclick="intent()">Share whatwebcando.today<br>with <b>Web Intents</b></button>
</p>

<p>
  <button class="btn btn-lg btn-default" onclick="share()">Share whatwebcando.today<br>with <b>Web Share</b></button>
</p>`,
        js: `function intent() {
  if (!("Intent" in window)) {
    alert('Web Intents API not supported.');
    return;
  }

  var intent = new Intent('http://webintents.org/share',
    'text/uri-list',
    'https://whatwebcando.today');
  navigator.startActivity(intent, function () {
    console.log('Successful share')
  }, function (error) {
    console.log('Error sharing:', error);
  });
}

function share() {
  if (!("share" in navigator)) {
    alert('Web Share API not supported.');
    return;
  }

  navigator.share({
      title: 'What Web Can Do Today',
      text: 'Can I rely on the Web Platform features to build my app? An overview of the device integration HTML5 APIs',
      url: 'https://whatwebcando.today/'
    })
    .then(() => console.log('Successful share'))
    .catch(error => console.log('Error sharing:', error));
}`
      },
      links: [
        {url: 'https://www.w3.org/TR/web-intents/', title: 'W3C Working Group Note about Web Intents'},
        {url: 'https://www.chromium.org/developers/web-intents-in-chrome', title: 'Web Intents in Chrome - description from 2012'},
        {url: 'https://paul.kinlan.me/what-happened-to-web-intents/', title: 'Paul Kinlan: What happened to Web Intents?'},
        {url: 'https://paul.kinlan.me/navigator.share/', title: 'Paul Kinlan: Simple sharing on the Web with navigator.share'},
        {url: 'https://wicg.github.io/web-share/', title: 'Web Share API Specification'}
      ]
    }),

    mediaRecorder: new Feature({
      id: 'recording',
      name: 'Recording Media',
      description: [`The <b>Media Recorder API</b> is a Web API allowing Web applications to record audio and video Media Streams, local and/or remote. It relies on the <code>mediaStream</code> object - see <a href="/camera-microphone.html">Audio & Video Capture</a>.`],
      api: `<dl>
        <dt><code>recorder = new MediaRecorder(mediaStream, options)</code></dt>
        <dd>Creates a media recorder out of a Media Stream. <code>options</code> selects e.g. the intended <code>MIME type</code> and/or the target bitrates.</dd>
        <dt><code>MediaRecorder.isMimeTypeSupported(mimeType)</code></dt>
        <dd>Static function checking if <code>mimeType</code> is, in principle, supported for recording.</dd>
        <dt><code>recorder.start(interval)</code></dt>
        <dd>Starts recording data, producing it as chunks in <code>ondataavailable</code>'s <code>event.data</code>, every <code>interval</code> ms, if explicited.</dd>
      </dl>`,
      tests: [Feature.windowContains('MediaRecorder')],
      caniuse: 'mediarecorder',
      demo: {
        html: `<video autoplay style="height:180px; width: 240px;" poster="https://image.freepik.com/free-icon/video-camera-symbol_318-40225.png"></video>
<p><button class="btn btn-lg btn-default" onclick="getStream()">Grab video & start recording</button></p>
<p><button class="btn btn-lg btn-default" onclick="download()">Download!</button></p>
  
<p><small>Demo by <a href="http://www.mcasas.tk/" target="_blank">Miguel Casas-Sanchez</a>.</small></p>`,
        cssHidden: `video {
  background-color: #fff;
}`,
        js: `function getUserMedia(options, successCallback, failureCallback) {
  var api = navigator.getUserMedia || navigator.webkitGetUserMedia ||
    navigator.mozGetUserMedia || navigator.msGetUserMedia;
  if (api) {
    return api.bind(navigator)(options, successCallback, failureCallback);
  }
}

var theStream;
var theRecorder;
var recordedChunks = [];

function getStream() {
  if (!navigator.getUserMedia && !navigator.webkitGetUserMedia &&
    !navigator.mozGetUserMedia && !navigator.msGetUserMedia) {
    alert('User Media API not supported.');
    return;
  }
  
  var constraints = {video: true, audio: true};
  getUserMedia(constraints, function (stream) {
    var mediaControl = document.querySelector('video');
    
    if ('srcObject' in mediaControl) {
      mediaControl.srcObject = stream;
      mediaControl.src = (window.URL || window.webkitURL).createObjectURL(stream);
    } else if (navigator.mozGetUserMedia) {
      mediaControl.mozSrcObject = stream;
    }
    
    theStream = stream;
    try {
      recorder = new MediaRecorder(stream, {mimeType : "video/webm"});
    } catch (e) {
      console.error('Exception while creating MediaRecorder: ' + e);
      return;
    }
    theRecorder = recorder;
    console.log('MediaRecorder created');
    recorder.ondataavailable = recorderOnDataAvailable;
    recorder.start(100);
  }, function (err) {
    alert('Error: ' + err);
  });
}

function recorderOnDataAvailable(event) {
  if (event.data.size == 0) return;
  recordedChunks.push(event.data);
}

function download() {
  console.log('Saving data');
  theRecorder.stop();
  theStream.getTracks()[0].stop();

  var blob = new Blob(recordedChunks, {type: "video/webm"});
  var url = (window.URL || window.webkitURL).createObjectURL(blob);
  var a = document.createElement("a");
  document.body.appendChild(a);
  a.style = "display: none";
  a.href = url;
  a.download = 'test.webm';
  a.click();
  
  // setTimeout() here is needed for Firefox.
  setTimeout(function () {
      (window.URL || window.webkitURL).revokeObjectURL(url);
  }, 100); 
}`
      },
      links: [
        {url: 'https://w3c.github.io/mediacapture-record/MediaRecorder.html', title: 'Specification Draft'},
        {url: 'https://webrtc.github.io/samples/src/content/getusermedia/record/', title: 'Demo recording local data'}
      ]
    }),

    realtime: new Feature({
      id: 'realtime',
      name: 'Real-Time Communication',
      description: [`Real-Time Communication in the Web, <b>WebRTC</b> in short, is a set of APIs allowing Web applications to send and receive streaming real-time video, audio and data to/from remote peers, without relying it through the centralized server. The server, implementing one of the specific signalling protocols, is needed for initial discovery and connection handshake, though. The APIs rely on the <code>mediaStream</code> object - see <a href="/camera-microphone.html">Audio & Video Capture</a>.`],
      api: `<dl>
        <dt><code>connection = new RTCPeerConnection(configuration)</code></dt>
        <dd>Creates a connection object that will be used to establish serverless connection between peers. The <code>configuration</code> may include the set of <code>iceServers</code> that will be used for discovery and connection handshake.</dd>
        <dt><code>connection.addEventListener('icecandidate', listener)</code></dt>
        <dd>An event fired when the signalling server registers a remote peer with which the connection may be established.</dd>
        <dt><code>connection.addStream(localMediaStream)</code></dt>
        <dd>Adds an existing local Media Stream (e.g. the local Web cam) to the remote peer connection.</dd>
        <dt><code>connection.onaddstream = event => video.src = URL.createObjectURL(event.stream)</code></dt>
        <dd>Registers an <code>onaddstream</code> event handler that, if and when called, retrieves the remote party's Media Stream and plugs it into a &lt;video> tag <code>video</code>.</dd>
        <dt><code>connection.createOffer(options)</code></dt>
        <dd>Returns a <code>Promise</code> resolved when the remote peer connects to the connections and streams offered.</dd>
        <dt><code>connection.createAnswer(options)</code></dt>
        <dd>Accepts the connection offerred by the remote peer. Returns a <code>Promise</code> resolved when the connection is established.</dd>
        <dt><code>dataChannel = connection.createDataChannel(label, configuration)</code></dt>
        <dd>Opens a data channel for the connection, allowing it to transmit arbitrary types of data.</dd>
        <dt><code>dataChannel.send(data)</code>
        <dd>Sends the data over the data channel to the remote peer.</dd>
        <dt><code>dataChannel.addEventListener('message', listener)</code></dt>
        <dd>An event fired when the data has been received via the data channel.</dd>
      </dl>`,
      tests: [Feature.windowContains('RTCPeerConnection')],
      caniuse: 'rtcpeerconnection',
      demo: {
        html: `
<p><button class="btn btn-lg btn-default" onclick="getStream()">Grab video & start local peer connection</button></p>

<p>Local video</p>
<video autoplay id="localVideo" style="height:180px; width: 240px;" poster="https://image.freepik.com/free-icon/video-camera-symbol_318-40225.png"></video>

<p>Remote video</p>
<video autoplay id="remoteVideo" style="height:180px; width: 240px;"></video>

<p><small>Demo by <a href="http://www.mcasas.tk/" target="_blank">Miguel Casas-Sanchez</a>.</small></p>`,
        cssHidden: `video {
  background-color: #fff;
}`,
        js: `function getUserMedia(options, successCallback, failureCallback) {
  var api = navigator.getUserMedia || navigator.webkitGetUserMedia ||
    navigator.mozGetUserMedia || navigator.msGetUserMedia;
  if (api) {
    return api.bind(navigator)(options, successCallback, failureCallback);
  }
}

var pc1;
var pc2;
var theStreamB;

function getStream() {
  if (!navigator.getUserMedia && !navigator.webkitGetUserMedia &&
    !navigator.mozGetUserMedia && !navigator.msGetUserMedia) {
    alert('User Media API not supported.');
    return;
  }
  
  var constraints = {
    video: true
  };
  getUserMedia(constraints, function (stream) {
    addStreamToVideoTag(stream, 'localVideo');

    // RTCPeerConnection is prefixed in Blink-based browsers.
    window.RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection;
    pc1 = new RTCPeerConnection(null);
    pc1.addStream(stream);
    pc1.onicecandidate = event => {
      if (event.candidate == null) return;
      pc2.addIceCandidate(new RTCIceCandidate(event.candidate));
    };

    pc2 = new RTCPeerConnection(null);
    pc2.onaddstream = event => {
      theStreamB = event.stream;
      addStreamToVideoTag(event.stream, 'remoteVideo');
    };
    pc2.onicecandidate = event => {
      if (event.candidate == null) return;
      pc1.addIceCandidate(new RTCIceCandidate(event.candidate));
    };

    pc1.createOffer({offerToReceiveVideo: 1})
      .then(desc => {
        pc1.setLocalDescription(desc);
        pc2.setRemoteDescription(desc);
        return pc2.createAnswer({offerToReceiveVideo: 1});
      })
      .then(desc => {
        pc1.setRemoteDescription(desc);
        pc2.setLocalDescription(desc);
      })
      .catch(err => {
        console.error('createOffer()/createAnswer() failed ' + err);
      });
  }, function (err) {
    alert('Error: ' + err);
  });
}

function addStreamToVideoTag(stream, tag) {
  var mediaControl = document.getElementById(tag);
  if ('srcObject' in mediaControl) {
    mediaControl.srcObject = stream;
    mediaControl.src = (window.URL || window.webkitURL).createObjectURL(stream);
  } else if (navigator.mozGetUserMedia) {
    mediaControl.mozSrcObject = stream;
  }
}`
      },
      links: [
        {url: 'https://w3c.github.io/webrtc-pc/', title: 'Specification Draft'},
        {
          url: 'http://www.html5rocks.com/en/tutorials/webrtc/basics/',
          title: 'HTML5 Rocks: Getting started with WebRTC'
        },
        {
          url: 'https://webrtc.github.io/samples/#peerconnection',
          title: 'WebRTC RTCPeerConnection and RTCDataChannel samples'
        },
        {
          url: 'https://webrtc.github.io/samples/src/content/peerconnection/pc1/',
          title: 'Simple demo with loopback connection'
        }
      ]
    }),

    geofencing: new Feature({
      id: 'geofencing',
      name: 'Geofencing',
      description: [`The <b>Geofencing API</b> allow authorized Web applications to define geographic areas and receive notifications when the device enters or leaves these areas without the need to periodically query the <a href="/geolocation.html">Geolocation API</a>. Thanks to the Service Worker being employed that allows code execution outside of the lifecycle of the owning Web application, the notification may be also received while the app is not opened in the browser.`,
        `As of August 2016, no vendor implemented the API and the proposal seems to be abandoned.`],
      api: `<dl>
        <dt><code>region = new CircularGeofenceRegion({name, latitude, longitude, radius})</code></dt>
        <dd>Creates a circular region definition with the coordinates and radius specified.</code></dt>
        <dt><code>serviceWorkerRegistration.geofencing.add(region, options)</code></dt>
        <dd>Sets up a region to be watched for and subscribes to the notification when the device enters or leaves the region.</dd>
        <dt><code>self.addEventListener('geofenceenter', listener)</code></dt>
        <dd>An event fired when the device enters one of the defined regions, provided as <code>event.geofence.region</code>.</dd>
        <dt><code>self.addEventListener('geofenceleave', listener)</code></dt>
        <dd>An event fired when the device leaves one of the defined regions, provided as <code>event.geofence.region</code>.</dd>
      </dl>`,
      tests: [Feature.windowContains('GeofenceManager')],
      links: [
        {url: 'https://w3c.github.io/geofencing-api/', title: 'Specification Draft'},
        {url: 'https://bugs.chromium.org/p/chromium/issues/detail?id=383125', title: 'Chrome Issue tracking the implementation trial and later removal'}
      ]
    }),

    payments: new Feature({
      id: 'payments',
      name: 'Payments',
      description: [`The <b>Payment Request API</b> allows Web applications to delegate the payment checkout process to the operating system, allowing
      it to use whatever methods and payment providers are natively available for the platform and configured for the user. This approach takes away the burden of handling
      complex checkout flows at the application side, reduces the scope of the payment provider integration and ensures better familiarity for the user.`,
      `With <code>supportedMethods</code> parameter the API allows the Web application to select the supported payment methods - for example only to allow credit card payments or
      payments processed by a specific 3rd-party provider - as well as configure its parameters. Methods are specified by the predefined identifier or by
      the 3rd-party URL. Note that the behaviors of the payment methods might vary. For example, the <code>basic-card</code> predefined provider does not
      process any actual payments - its role is reduced to collecting the credit card details and returning it to the requesting Web application. 
      Although 3rd-party providers might as well proceed with the actual money transfer as a part of the flow.`,
      `With <code>details</code> parameter the Web application should specify the total amount and currency of the payment. It also allows setting up
      the order summary information including the subtotals, order items and shipping options.`,
      `With <code>options</code> parameter the Web application might specify what kind of customer data it requires to be able to fulfill the request.
      It may require a shipping address (<code>requestShipping</code>), email (<code>requestPayerEmail</code>), phone (<code>requestPayerPhone</code>) 
      or name (<code>requestPayerName</code>).`,
      `The only payment method available on iOS devices is <a href="https://www.apple.com/apple-pay/" target="_blank">Apple Pay</a> and it is only functional on devices with fingerprint authentication (Touch ID). It is accessible both via the standard Payment Request API described here as well as the older proprietary non-standard <code>ApplePaySession</code> API. The <code>basic-card</code> payments are not supported.`],
      api: `<dl>
        <dt><code>paymentRequest = new PaymentRequest(paymentMethods, details, options)</code></dt>
        <dd>Creates a payment request object with the requested amounts, currencies and methods configured.</dd>
        <dt><code>paymentRequest.canMakePayment()</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the value indicating if it is possible to conduct a payment using any of the <code>paymentMethods</code> specified.</dd>
        <dt><code>paymentRequest.show()</code></dt>
        <dd>Presents the checkout confirmation UI to the user or redirects to the system-defined application that accepts payments by a method selected.
          Returns a <code>Promise</code> resolved with the <code>response</code> object when the payment is successfully confirmed by the payment provider.
          Note that it may or may not already denote the money being transferred - it depends on the selected payment method implementation.</dd>
        <dt><code>request.addEventListener('shippingaddresschange', listener)</code></dt>
        <dd>An event fired when the user changes the shipping address data, allowing updating the request's <code>details</code> using <code>event.updateWith()</code> method.</dd>
        <dt><code>request.addEventListener('shippingoptionchange', listener)</code></dt>
        <dd>An event fired when the user changes the shipping options (delivery vs. pickup etc.), allowing updating the request's <code>details</code> using <code>event.updateWith()</code> method.</dd>
        <dt><code>event.updateWith(promise)</code></dt>
        <dd>Waits for a <code>promise</code> to resolve with the new payment details and puts it into the request's <code>details</code>.</dd>
        <dt><code>response.toJSON()</code></dt>
        <dd>A convenience method that serializes the payment response (including the requested payment details and the data returned by the provider) into JSON intended to be sent to server-side for order processing.</dd>
        <dt><code>response.complete(result)</code></dt>
        <dd>Signals the browser that the app-specific steps of payment processing (like sending the order data to the server-side) has completed. Returns a <code>Promise</code> resolved when the Payment Request UI is cleared.</dd>
      </dl>`,
      tests: [
        Feature.windowContains('PaymentRequest'),
        Feature.windowContains('ApplePaySession', false)
      ],
      caniuse: 'payment-request',
      demo: {
        html: `<p><button class="btn btn-default" onclick="donate()">Donate 10€ to What Web Can Do 😉</button> (demo only, no actual payment is processed)</p>

<p id="log"></p>

<p><small>Demo based on <a href="https://googlechrome.github.io/samples/paymentrequest/credit-cards/">Google Chrome GitHub repository</a>.</small></p>`,
        js: `/**
 * Builds PaymentRequest for credit cards, but does not show any UI yet.
 */
function initPaymentRequest() {
  let networks = ['amex', 'jcb', 'visa', 'maestro', 'mastercard'];
  
  let supportedInstruments = [{
    supportedMethods: 'basic-card',
    data: {
      supportedNetworks: networks, 
      supportedTypes: ['debit', 'credit', 'prepaid']
    }
  }, {
    supportedMethods: 'https://apple.com/apple-pay',
    data: {
        version: 2,
        supportedNetworks: networks,
        countryCode: 'US',
        merchantIdentifier: 'whatwebcando.today.sample',
        merchantCapabilities: ['supportsDebit', 'supportsCredit', 'supports3DS']
    }
  }];

  let details = {
    total: {label: 'Donation', amount: {currency: 'EUR', value: '10.00'}},
    displayItems: [
      {
        label: 'Original donation amount',
        amount: {currency: 'EUR', value: '15.00'}
      },
      {
        label: 'Friends and family discount',
        amount: {currency: 'EUR', value: '-5.00'}
      }
    ]
  };

  return new PaymentRequest(supportedInstruments, details);
}

/**
 * Invokes PaymentRequest for credit cards.
 */
function onBuyClicked(request) {
  request.show()
    .then(instrumentResponse => sendPaymentToServer(instrumentResponse))
    .catch(err => document.getElementById('log').innerText = err);
}

/**
 * Simulates processing the payment data on the server.
 */
function sendPaymentToServer(instrumentResponse) {
  // There's no server-side component of these samples. No transactions are
  // processed and no money exchanged hands. Instantaneous transactions are not
  // realistic. Add a 2 second delay to make it seem more real.
  
  window.setTimeout(function () {
    instrumentResponse.complete('success')
        .then(() => document.getElementById('log').innerHTML = resultToTable(instrumentResponse))
        .catch(err => document.getElementById('log').innerText = err);
  }, 2000);
}

/**
 * Converts the payment instrument into a JSON string.
 */
function resultToTable(result) {
  return '<table class="table table-striped">' +
    '<tr><td>Method name</td><td>' + result.methodName + '</td></tr>' +
    '<tr><td>Billing address</td><td>' + (result.details.billingAddress || {}).addressLine + ', ' + (result.details.billingAddress || {}).city + '</td></tr>' +
    '<tr><td>Card number</td><td>' + result.details.cardNumber + '</td></tr>' +
    '<tr><td>Security code</td><td>' + result.details.cardSecurityCode + '</td></tr>' +
    '<tr><td>Cardholder name</td><td>' + result.details.cardholderName + '</td></tr>' +
    '<tr><td>Expiry date</td><td>' + result.details.expiryMonth + '/' + result.details.expiryYear + '</td></tr>' +
    '</table>';
}

function donate() {
  if (!window.PaymentRequest) {
    alert('This browser does not support Web Payments API');
    return;
  }
    
  let request = initPaymentRequest();
  onBuyClicked(request);
}`
      },
      links: [
        {url: 'https://www.w3.org/TR/payment-request/', title: 'Specification'},
        {url: 'https://developers.google.com/web/fundamentals/payments/', title: 'Google Developers: Introducing the Payment Request API'},
        {url: 'https://developers.google.com/web/fundamentals/payments/deep-dive-into-payment-request', title: 'Google Developers: Deep Dive into the Payment Request API'}
      ]
    }),

    credentials: new Feature({
      id: 'credentials',
      name: 'Credentials',
      description: [`The <b>Credential Management API</b> allows authorized Web applications to store and request user credentials (like login and password
        or federated login data) programmatically on behalf of the user. The API offers a replacement for browser built-in or 3rd-party password stores
        which allows the Web application to instrument when and how the credentials are stored and read, for example to offer automatic sign-in capability.`,
      `When retrieving the previously stored credential, the Web application may decide if the user mediation is expected. When <code>mediation</code>
       flag is set to <code>silent</code>, the credential will only be resolved if the user had previously stored the single credential for this application.
       With <code>optional</code> option set, the UI to choose the credential will appear unless there's a single credential stored. Finally, with
       <code>required</code> option, the UI will always be shown, regardless of the previously stored credentials existence.`],
      api: `<dl>
        <dt><code>credential = new PasswordCredential(form)</code></dt>
        <dd>Creates the credential object based on the username and password data detected in a HTML <code>&lt;form&gt;</code> element.</dd>
        <dt><code>credential = new PasswordCredential({id, password, name, iconURL})</code></dt>
        <dd>Creates the credential object manually based on the data provided.</dd>
        <dt><code>credential = new FederatedCredential({id, name, iconURL, provider, protocol})</code></dt>
        <dd>Creates the credential object based on the federated login service specified with <code>provider</code> and <code>protocol</code> options.</dd>
        <dt><code>navigator.credentials.store(credential)</code></dt>
        <dd>Stores the credential provided for future access. Returns a <code>Promise</code> resolved when the credential is successfully persisted by the browser.</dd>
        <dt><code>navigator.credentials.get({mediation})</code></dt>
        <dd>Retrieves the previously stored credential from the browser, optionally with user mediation (UI). Returns a <code>Promise</code> resolved with fetched credential or <code>null</code>.</dd>
        <dt><code>navigator.credentials.preventSilentAccess()</code></dt>
        <dd>Ensures the user mediation is required on the next credential access request, effectively "logging out" the user.</dd>
      </dl>`,
      tests: [Feature.asyncRawTest('navigator', 'credentials', () => {
        if (!navigator.credentials) {
          return Promise.resolve(false)
        }

        return navigator.credentials.get({mediation: 'silent', unmediated: true})
          .then(() => true)
          .catch(() => false)
      })],
      caniuse: 'credential-management',
      demo: {
        html: `<div class="row">
<div class="col-sm-6">
  <form id="credential-form" onsubmit="storeCredential(event)">
    <p><b>Store your credentials:</b></p>
    <p>
      <label>login: <input type="text" name="username" class="form-control" required autocomplete="username"></label>
      <label>password: <input type="password" name="password" class="form-control" required autocomplete="current-password"></label>
    </p>
    <p><button type="submit" class="btn btn-default">Store credential</button></p>
  
    <p class="user-mediation">
      <b>User mediation:</b><br/>
      <label><input type="radio" name="mediation" value="silent"> silent</label>
      <label><input type="radio" name="mediation" value="optional" checked> optional</label>
      <label><input type="radio" name="mediation" value="required"> required</label>
    </p>
    <p><button type="button" onclick="requestCredential()" class="btn btn-default">Request credential</button></p>
    <p><button type="button" onclick="preventSilentAccess()" class="btn btn-default">Prevent silent access (logout)</button></p>
  </form>
</div>
<div class="col-sm-6" id="result"></div>
</div>`,
        js: `function storeCredential() {
  event.preventDefault();

  if (!navigator.credentials) {
    alert('Credential Management API not supported');
    return;
  }
  
  let credentialForm = document.getElementById('credential-form');
  let credential = new PasswordCredential(credentialForm);
  navigator.credentials.store(credential)
    .then(() => log('Storing credential for <b>' + credential.id + '</b> (result cannot be checked by the website)'))
    .catch(err => log('Error storing credentials: ' + err));
}

function requestCredential() {
  if (!navigator.credentials) {
    alert('Credential Management API not supported');
    return;
  }
  
  let mediationValue = document.getElementById('credential-form').mediation.value;
  navigator.credentials.get({password: true, mediation: mediationValue})
    .then(credential => {
      let result = 'none';
      if (credential) {
        result = credential.id + ', ' + credential.password.replace(/./g, '*');
      }
      log('Credential read: <b>' + result + '</b>');
    })
    .catch(err => log('Error reading credentials: ' + err));
}

function preventSilentAccess() {
  if (!navigator.credentials) {
    alert('Credential Management API not supported');
    return;
  }
  
  navigator.credentials.preventSilentAccess()
    .then(() => log('Silent access prevented (mediation will be required for next credentials.get() call)'))
    .catch(err => log('Error preventing silent acces: ' + err));
}

function log(info) {
  var logTarget = document.getElementById('result');
  var timeBadge = new Date().toTimeString().split(' ')[0];
  var newInfo = document.createElement('p');
  newInfo.innerHTML = '<span class="badge">' + timeBadge + '</span> ' + info + '</b>.';
  logTarget.appendChild(newInfo);
}`,
        cssHidden: `.user-mediation label {
  margin-right: 1em;
}`
      },
      links: [
        {url: 'https://w3c.github.io/webappsec-credential-management/', title: 'Specification Draft'},
        {url: 'https://developers.google.com/web/updates/2016/04/credential-management-api', title: 'Google Developers: Streamlining the Sign-in Flow Using Credential Management API'},
        {url: 'https://medium.com/dev-channel/sign-in-on-the-web-credential-management-api-and-best-practices-d21aed14b6fe', title: 'Sign-in on the Web — Credential Management API and Best Practices'},
        {url: 'https://polykart-credential-payment.appspot.com/', title: 'Auto sign-in demo'}
      ]
    }),

    memory: new Feature({
      id: 'memory',
      name: 'Device Memory',
      description: [`The <b>Device Memory API</b> allows Web applications to assess the class of the device by the size of the RAM memory installed.
        It might be used to identify the lower-end devices to provide the reduced, lightweight experience of the website for performance reasons.
        The value provided by the API does not hint how much of the memory is actually available for the application to use - its purpose is only
        to serve as a device class indication.`,
      `The API consists of two parts. The first is the memory size exposed via the JavaScript property. The second is the <a href="http://httpwg.org/http-extensions/client-hints.html" target="_blank">Client Hint</a> mechanism of the browser
        that sends the total device memory information as <code>Device-Memory</code> HTTP request header when the server previously opted-in
        to receiving this information with <code>Accept-CH: Device Memory</code> HTTP response header, so that the server side might decide to serve 
        the content optimized for the particular class of device.`],
      api: `<dl>
        <dt><code>navigator.deviceMemory</code></dt>
        <dd>Returns the approximate total RAM memory size of the device, in GiB.</dd>
      </dl>`,
      tests: [Feature.navigatorContains('deviceMemory')],
      demo: {
        html: `Your device memory is ~<b id="result">unknown</b> GiB.`,
        js: `document.getElementById('result').innerHTML = navigator.deviceMemory || 'unknown'`
      },
      links: [
        {url: 'https://w3c.github.io/device-memory/', title: 'Specification Draft'}
      ]
    }),

    usb: new Feature({
      id: 'usb',
      name: 'USB',
      description: [`The <b>WebUSB API</b> allows Web applications to interact with the Universal Serial Bus-compatible devices available in the system.
      In order to authorize the application to get the access to the device, user needs to confirm the intent in the browser's UI that in turn may only be 
      initiated with a gesture (for example, a button click, but not automatically by arbitrary JavaScript).`,
      `The API is based on the <a href="http://www.usb.org/developers/docs/" target="_blank">USB 3.1 specification</a> and exposes all the USB primitives to JavaScript
       - including configurations, interfaces, endpoints and all the transfer types: CONTROL (suitable for commands), INTERRUPT (suitable for small time-sensitive data), 
       BULK (suitable for large time-sensitive data) and ISOCHRONOUS (suitable for streams, for example media)`,
      `The specification, apart from the JavaScript API, defines a Platform Descriptor object that might be implemented at the device side to advertize its
      support for WebUSB. Google Chrome's implementation uses it to notify the user about the landing page of the plugged in device with the system notification.`],
      api: `<p><b>Connecting to the device</b></p>
      <dl>
        <dt><code>navigator.usb.requestDevice(filters)</code></dt>
        <dd>Returns the <code>Promise</code> resolved with the device object that matches the specified filter by <a href="http://www.linux-usb.org/usb.ids">predefined</a>
         vendor ID, product ID, class or subclass code, protocol code or serial number.</dd>
        <dt><code>navigator.usb.getDevices()</code></dt>
        <dd>Returns the <code>Promise</code> resolved with the device objects for the devices previously authorized for this application.</dd>
        <dt><code>navigator.usb.addEventListener('connect', listener)</code></dt>
        <dd>An event fired when the already authorized device has been connected to the system, containing the connected device object.</dd>
        <dt><code>navigator.usb.addEventListener('disconnect', listener)</code></dt>
        <dd>An event fired when the previously connected device has been disconnected from the system, containing the disconnected device object.</dd>
      </dl>
      <p><b>Session setup</b></p>
      <dl>
        <dt><code>device.open()</code></dt>
        <dd>Opens the communication session with the device. Returns a <code>Promise</code> resolved when the session has been opened.</dd>
        <dt><code>device.close()</code></dt>
        <dd>Closes the communication session with the device. Returns a <code>Promise</code> resolved when the session has been closed.</dd>
        <dt><code>device.configurations</code></dt>
        <dd>Contains the device-provided configuration objects with <code>configurationValue</code> identifier and the list of available <code>interfaces</code>.</dd>
        <dt><code>device.selectConfiguration(configurationValue)</code></dt>
        <dd>Selects the configuration of the device. Returns a <code>Promise</code> resolved when the setup has been applied.</dd>
        <dt><code>device.claimInterface(interfaceNumber)</code></dt>
        <dd>Claims the interface of the device (by the number specified in <code>configuration.interfaces</code>. Returns a <code>Promise</code> resolved when the setup has been applied.</dd>
      </dl>
      <p><b>Data transfers</b></p>
      <dl>
        <dt><code>device.controlTransferIn(setup, length)</code></dt>
        <dd>Waits for a specified control transfer from the device. Returns the <code>Promise</code> resolved with the transfer data and status.</dd>
        <dt><code>device.controlTransferOut(setup, data)</code></dt>
        <dd>Sends a specified control transfer to the device. Returns the <code>Promise</code> resolved with the transfer status and the number of bytes written.</dd>
        <dt><code>device.transferIn(endpointNumber, length)</code></dt>
        <dd>Waits for a bulk or interrupt transfer from the device on a specified endpoint. Returns the <code>Promise</code> resolved with the transfer data and status.</dd>
        <dt><code>device.transferOut(endpointNumber, data)</code></dt>
        <dd>Sends a bulk or interrupt transfer to the specified endpoint of the device. Returns the <code>Promise</code> resolved with the transfer status and the number of bytes written.</dd>
        <dt><code>device.isochronousTransferIn(endpointNumber, packetLengths)</code></dt>
        <dd>Waits for a specified isochronous transfer from the device. Returns the <code>Promise</code> resolved with the list of packets received, each containing data and status.</dd>
        <dt><code>device.isochronousTransferOut(endpointNumber, data, packetLengths)</code></dt>
        <dd>Sends a specified isochronous transfer to the device. Returns the <code>Promise</code> resolved with the list of packets sent, each containing status and the number of bytes written.</dd>
      </dl>`,
      tests: [Feature.navigatorContains('usb')],
      caniuse: 'webusb',
      demo: {
        html: `<button class="btn btn-default" id="arduinoButton">Talk to Arduino</button>

<div id="target"></div>

<p><small>Demo from <a href="https://developers.google.com/web/updates/2016/03/access-usb-devices-on-the-web" target="_blank">Google Developers</a> article.</small></p>`,
        js: `document.getElementById('arduinoButton').addEventListener('click', function () {
  if (navigator.usb) {
    talkToArduino();
  } else {
    alert('WebUSB not supported.');
  }
});

async function talkToArduino() {
  try {
    let device = await navigator.usb.requestDevice({ filters: [{ vendorId: 0x2341 }] });
    await device.open(); // Begin a session.
    await device.selectConfiguration(1); // Select configuration #1 for the device.
    await device.claimInterface(2); // Request exclusive control over interface #2.
    await device.controlTransferOut({
      requestType: 'class',
      recipient: 'interface',
      request: 0x22,
      value: 0x01,
      index: 0x02
    });
  
    // Ready to receive data
    let result = device.transferIn(5, 64); // Waiting for 64 bytes of data from endpoint #5.
    let decoder = new TextDecoder();
    document.getElementById('target').innerHTML = 'Received: ' + decoder.decode(result.data);
  } catch (error) {
    document.getElementById('target').innerHTML = error;
  }
}`
      },
      links: [
        {url: 'https://wicg.github.io/webusb/', title: 'Specification Draft'},
        {url: 'https://developers.google.com/web/updates/2016/03/access-usb-devices-on-the-web', title: 'Google Developers: Access USB Devices on the Web'}
      ]
    }),

    sms: new Feature({
      id: 'sms',
      name: 'SMS/MMS',
      description: [`Allowing Web applications to access SMS and MMS messages on the device was a goal of <b>Messaging API</b>. 
        It was designed to cover the functionality of the native mobile messaging applications, including browsing, creating and managing the messages.
        Its early version was implemented only on now-defunct Firefox OS. As of late 2017 it was the only actual implementation of SMS messaging in the Web - no browser vendor expresses an interest anymore.`,
        `There exists another SMS-related <a href="https://discourse.wicg.io/t/proposal-sign-up-api-for-web/1844" target="_blank">API proposal</a> to focus on SMS 
        as a carrier of one-time password to be used in multiple factor authentication schemes. As of end of 2017 this proposal is still in early design phase.`],
      api: `<p><b>Firefox OS API</b></p>
      <dl>
        <dt><code>navigator.mozSms.send(number, message)</code></dt>
        <dd>Sends a SMS to a specified number. The sending and delivery status was to be tracked via 
          listening to <code>onsent</code>, <code>ondeliverysuccess</code> and <code>ondeliveryerror</code> events.</dd>
        <dt><code>navigator.mozSms.getMessages(filter)</code></dt>
        <dd>Returns the cursor that allows iterating through the messages matching the filter provided.</dd>
      </dl>
      <p><b>Messaging API proposal</b></p>
      <dl>
        <dt><code>navigator.messaging.sms.send(number, message, serviceId)</code></dt>
        <dd>Sends a SMS to a specified number. The sending and delivery status was to be tracked via 
          listening to <code>onsent</code>, <code>ondeliverysuccess</code> and <code>ondeliveryerror</code> events.</dd>
        <dt><code>navigator.messaging.mms.send(content)</code></dt>
        <dd>Sends a MMS to a specified number. The sending and delivery status was to be tracked via 
          listening to <code>onsent</code>, <code>ondeliverysuccess</code> and <code>ondeliveryerror</code> events.</dd>
        <dt><code>navigator.messaging.findMessages(filter, options)</code></dt>
        <dd>Returns the <code>Promise</code> resolved with the messages matching by the filter provided.</dd>
      </dl>`,
      tests: [
        Feature.navigatorContains('sms'),
        Feature.navigatorContains('mms'),
        Feature.navigatorContains('messaging')
      ],
      links: [
        {url: 'https://www.w3.org/TR/messaging/', title: 'Messaging API specification proposal'},
        {url: 'https://developer.mozilla.org/en-US/docs/Archive/B2G_OS/API/Mobile_Messaging_API', title: 'Firefox OS defunct implementation documentation'}
      ]
    }),

    scheduler: new Feature({
      id: 'scheduler',
      name: 'Task Scheduling',
      description: [`The first attempt to provide the Web applications an ability to be notified according to the system-level scheduler was called <strong>Web Alarms API</strong>. 
      It was abandoned in 2013 in favor of the newer <strong>Task Scheduler API</strong> proposal based on Service Worker primitives.`,
      `The API's idea is to act as a wrapper for the underlying operating system scheduler and allow authorized Web applications implementing scenarios such as alarms, reminders or periodic data synchronization.
      It is supposed to be able to wake up the system at the specific time or in the first possible moment after the scheduled time and run the user-defined handler within the Service Worker instance.`,
      `The API is not implemented by any browser vendor as of the end of 2017 and no browser vendor seem to signal any interest.`],
      api: `<dl>
        <dt><code>navigator.serviceWorker.getRegistration()</code><br>
          <code>&nbsp;&nbsp;.then(reg => reg.taskScheduler.add(time, [data])</code></dt>
        <dd>Schedules an event to be triggered within the Service Worker instance at the specified <code>time</code> with the specified <code>data</code> payload.</dd>
        <dt><code>reg.taskScheduler.getPendingTasks()</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the events already scheduled by the current application.</dd>
        <dt><code>self.addEventListener('task', listener)</code></dt>
        <dd>An event fired within the Service Worker at the scheduled time (or as soon as it is possible after) with the <code>task</code> data.</dd>
      </dl>`,
      tests: [
        Feature.navigatorContains('alarms', false),
        Feature.serviceWorkerRegistrationContains('taskScheduler')
      ],
      links: [
        {url: 'https://www.w3.org/TR/task-scheduler/', title: 'Task Scheduler API specification proposal'},
        {url: 'https://www.w3.org/TR/2013/WD-web-alarms-20130205/', title: 'Web Alarms API abandoned proposal'}
      ]
    }),

    vr: new Feature({
      id: 'vr',
      name: 'Virtual & Augmented Reality',
      description: [`The support for Virtual and Augmented Reality for the Web applications as of January 2018 is limited and mostly experimental.
        There are two APIs available. The first one - <b>WebVR API</b> - is available in some browsers for some particular VR environments.
        The newer one - <b>WebXR Device API</b> - which tries to approach the topic in a more generic fashion, including AR or Mixed Reality devices, is in the development.`,
      `Both APIs share the same fundamental concepts. Their scope is to allow authorized Web applications to discover available VR/AR devices, 
        establish a session with the device, read the device-specific geometry data required to prepare the proper rendering and bind a <code>&lt;canvas&gt;</code>
        element as a visual layer onto the device.`,
      `This way the rendering details are handled by the existing canvas interfaces like <a href="https://developer.mozilla.org/pl/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL" target="_blank">WebGL context</a>
        and the implementators very often delegate the rendering itself to the specialized libraries like <a href="https://aframe.io/" target="_blank">A-Frame</a>.`],
      api: `<p><b>Older WebVR API</b></p>
      <dl>
        <dt><code>navigator.getVRDisplays()</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the list of available <code>vrDevice</code> objects when they have become available.</dd>
        <dt><code>vrDevice.capabilities</code></dt>
        <dd>Lists the capabilities of the current VR device, including <code>hasExternalDisplay</code> or <code>canPresent</code> boolean flags.</dd>
        <dt><code>vrDevice.requestPresent(layers)</code></dt>
        <dd>Requests putting the specified visual layers onto VR device's display and starts a session with the device.
          A layer might be represented by an object containing canvas rendering context that defines the rendering that will be presented (<code>{source: canvasContext}</code>).</dd>
        <dt><code>vrDevice.getFrameData(frameData)</code></dt>
        <dd>Fills the passed <code>frameData</code> object with the projection matrices needed to render a frame.</dd>
        <dt><code>vrDevice.requestAnimationFrame(callback)</code></dt>
        <dd>Registers a <code>callback</code> that will be executed within the next rendering frame on the VR device.</dd>
        <dt><code>vrDevice.submitFrame()</code></dt>
        <dd>Indicates that the layers canvases are ready to be rendered as a frame on the VR device.</dd>
        <dt><code>vrDevice.exitPresent()</code></dt>
        <dd>Requests finishing the current session. Returns a <code>Promise</code> resolved when the VR session is finished.</dd>
      </dl>
      <p><b>Newer WebXR Device API</b></p>
      <dl>
        <dt><code>navigator.xr.requestDevice()</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the selected AR/VR <code>xrDevice</code> object when it has become available.</dd>
        <dt><code>xrDevice.supportsSession({ exclusive: true })</code></dt>
        <dd>Returns a <code>Promise</code> resolved if the current AR/VR device allows exclusive immersive sessions.</dd>
        <dt><code>xrDevice.requestSession({ exclusive: true, outputContext: canvasContext })</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the exclusive device session object <code>xrSession</code> after it has been established.
          Can get <code>outputContext</code> canvas context object that defines the rendering that will be presented.</dd>
        <dt><code>xrSession.requestFrameOfReference('headModel')</code></dt>
        <dd>Returns a <code>Promise</code> resolved with the frame of reference that provides a coordinate system for a given display type.</dd>
        <dt><code>xrSession.requestAnimationFrame(callback)</code></dt>
        <dd>Registers a <code>callback</code> that will be executed within the next rendering frame within the AR/VR session.</dd>
        <dt><code>xrSession.end()</code></dt>
        <dd>Requests finishing the current session. Returns a <code>Promise</code> resolved when the AR/VR session is finished.</dd>
      </dl>`,
      caniuse: 'webvr',
      tests: [
        Feature.navigatorContains('getVRDisplays'),
        Feature.navigatorContains('xr'),
      ],
      demo: {
        html: `<p><button type="button" class="btn btn-default" id="startVRButton">Check for VR device</button></p>
<ul id="result"></ul>
<p>
  <a href="https://webvr.info/samples/" target="_blank">Browse demos by Google</a><br/>
  <a href="https://mozvr.com/mobile/" target="_blank">Browse demos by Mozilla</a>
</p>`,
        js: `document.getElementById('startVRButton').addEventListener('click', function () {
  if (navigator.getVRDisplays) {
    checkForVR();
  } else {
    alert('WebVR API is not supported.');
  }
});
        
async function checkForVR() {
  try {
    const displays = await navigator.getVRDisplays()
   
    if (!displays.length) {
      throw 'VR supported, but no VR displays available';
    }
    
    const result = document.getElementById('result');
        
    displays.forEach(function (display) {
      let li = document.createElement('li');
      li.innerHTML = display.displayName + ' (' + display.displayId + ')';
      result.appendChild(li);
    })
    
  } catch (err) {
    alert(err);
  }
}`
      },
      links: [
        {url: 'https://immersive-web.github.io/webvr/spec/1.1/', title: 'WebVR API Specification'},
        {url: 'https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API/Using_the_WebVR_API', title: 'MDN: Using the WebVR API'},
        {url: 'https://immersive-web.github.io/webxr/', title: 'WebXR Device API Specification'},
        {url: 'https://github.com/immersive-web/webxr/blob/master/explainer.md', title: 'WebXR Device API Explained'}
      ]
    })
  };

  if (global.WWCD.container) { // web run
    global.WWCD.container.configure(register => register.singletons({
      features: features
    }));
  } else { // build run
    global.features = features;
    global.groups = require('../../build/groups.json')
  }

})(function () {
  let global = typeof exports === 'object' ? exports : window;
  global.WWCD = global.WWCD || {};
  return global;
}());
