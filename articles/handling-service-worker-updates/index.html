<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="Can I rely on the Web Platform features to build my app? An overview of the device integration HTML5 APIs" name=description> <meta content="width=device-width,initial-scale=1" name=viewport> <base href=/ > <link href=https://fonts.gstatic.com/s/sourcesanspro/v13/6xK3dSBYKcSV-LCoeQqfX1RYOo3qOK7lujVj9w.woff2 rel=preload type=font/woff2 as=font crossorigin=anonymous> <link href=https://fonts.gstatic.com/s/sourcesanspro/v13/6xKydSBYKcSV-LCoeQqfX1RYOo3ig4vwlxdu3cOWxw.woff2 rel=preload type=font/woff2 as=font crossorigin=anonymous> <link href=/Material-Design-Icons.woff rel=preload type=font/woff2 as=font crossorigin=anonymous> <style>@font-face{font-family:'Source Sans Pro';font-style:normal;font-weight:400;font-display:swap;src:local('Source Sans Pro Regular'),local('SourceSansPro-Regular'),url(https://fonts.gstatic.com/s/sourcesanspro/v13/6xK3dSBYKcSV-LCoeQqfX1RYOo3qOK7lujVj9w.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Source Sans Pro';font-style:normal;font-weight:700;font-display:swap;src:local('Source Sans Pro Bold'),local('SourceSansPro-Bold'),url(https://fonts.gstatic.com/s/sourcesanspro/v13/6xKydSBYKcSV-LCoeQqfX1RYOo3ig4vwlxdu3cOWxw.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:"Material Design Icons";src:url(/Material-Design-Icons.woff) format("woff");font-weight:400;font-style:normal}</style> <link href=icon-76x76.png rel=apple-touch-icon sizes="60x60 72x72 76x76"> <link href=icon-120x120.png rel=apple-touch-icon sizes="114x114 120x120"> <link href=icon-144x144.png rel=apple-touch-icon sizes=144x144> <link href=icon-152x152.png rel=apple-touch-icon sizes=152x152> <link href=icon-180x180.png rel=apple-touch-icon sizes="167x167 180x180"> <link href=icon-32x32.png rel=icon sizes="16x16 32x32" type=image/png> <link href=icon-96x96.png rel=icon sizes=96x96 type=image/png> <link href=icon-192x192.png rel=icon sizes=192x192 type=image/png> <link href=manifest.json rel=manifest> <link href=client/main.981014900.css rel=stylesheet><link href=client/[slug].657368e0.css rel=stylesheet><link href=client/Article.15023632.css rel=stylesheet><link href=client/PromoBox.ad64a895.css rel=stylesheet><link href=client/prism.7976db51.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>What Web Can Do Today: Handling Service Worker updates – how to keep the app updated and stay sane</title> <meta content="What Web Can Do Today: Handling Service Worker updates – how to keep the app updated and stay sane" property=og:title> <meta content="Most of the Service Worker tutorials we can find on the Web focus on the initial development efforts needed to get the offline mode capabilities or performance gains for subsequent visits. But for production readiness, it is not enough, though. We need to have the update strategy in place not to cut off our users from actually getting the updates of our PWA." property=og:description> <meta content=https://whatwebcando.today//articles/handling-service-worker-updates/ property=og:url> <meta content=https://whatwebcando.today//articleimgs/floor-plan-on-table.pexels.jpg property=og:image> <meta content="What Web Can Do Today: Handling Service Worker updates – how to keep the app updated and stay sane" name=twitter:title> <meta content="Most of the Service Worker tutorials we can find on the Web focus on the initial development efforts needed to get the offline mode capabilities or performance gains for subsequent visits. But for production readiness, it is not enough, though. We need to have the update strategy in place not to cut off our users from actually getting the updates of our PWA." name=twitter:description> <meta content=https://whatwebcando.today//articleimgs/floor-plan-on-table.pexels.jpg name=twitter:image><noscript id=sapper-head-end></noscript> <meta content=yes name=apple-mobile-web-app-capable> <meta content=yes name=mobile-web-app-capable> <meta content="What Web Can Do Today" name=application-name> <meta content="What Web Can Do" name=apple-mobile-web-app-title> <meta content=https://whatwebcando.today/icon-144x144.png name=msapplication-TileImage> <meta content=#ffffff name=theme-color> <meta content=#ffffff name=msapplication-navbutton-color> <meta content=black-translucent name=apple-mobile-web-app-status-bar-style> <meta content=/ name=msapplication-starturl> <meta content=website property=og:type> <meta content=WhatWebCanDo property=og:site_name> <meta content=summary name=twitter:card> <meta content=@WhatWebCanDo name=twitter:site> <meta content="ArwJxpJHLSWVBvjjQdrLQmaNmEWqwy8avXhfQz6LucaHi6E8WQqBaOblE0Z5VKA6J9kgb07nziI5EF/LmdX6+woAAABSeyJvcmlnaW4iOiJodHRwczovL3doYXR3ZWJjYW5kby50b2RheTo0NDMiLCJmZWF0dXJlIjoiV2ViTkZDIiwiZXhwaXJ5IjoxNTg2MTkzMzI1fQ==" http-equiv=origin-trial> <meta content=AvXPG1STQvEBgDH2JFiDYWH1E1Eev55sYyz+szZiCeHhwQ/VAGicjx09J1WuU2Oj5q2WRr8zZsCe7jrd+a8zTA4AAABUeyJvcmlnaW4iOiJodHRwczovL3doYXR3ZWJjYW5kby50b2RheTo0NDMiLCJmZWF0dXJlIjoiV2FrZUxvY2siLCJleHBpcnkiOjE1ODYxOTMzOTh9 http-equiv=origin-trial> <meta content=AokzD/SJeJfcKJARUtujICN14urOGYKGGlHJWE2Aixopd5YQcdCwchsqcwS84XJSX6PJTkMuabIcE1ZRZxuMzgEAAABXeyJvcmlnaW4iOiJodHRwczovL3doYXR3ZWJjYW5kby50b2RheTo0NDMiLCJmZWF0dXJlIjoiU21zUmVjZWl2ZXIiLCJleHBpcnkiOjE1ODM3NzQwODl9 http-equiv=origin-trial> <meta content=AkFCG08Zf0cVbOTjoMNOXQW/DP/Gwg4ZAdNG4Z+5fcjAI4XHor6CzKgjvfSZz3v6iPS0iYwtySnCA7gx3lxVYwoAAABgeyJvcmlnaW4iOiJodHRwczovL3doYXR3ZWJjYW5kby50b2RheTo0NDMiLCJmZWF0dXJlIjoiTm90aWZpY2F0aW9uVHJpZ2dlcnMiLCJleHBpcnkiOjE1ODgzNDI5NDF9 http-equiv=origin-trial> </head> <body> <div id=sapper> <header class="svelte-1cc53ms text-center"> <nav> <ul class=svelte-1cc53ms> <li class=svelte-1cc53ms><a href=. class=svelte-1cc53ms>Features</a></li> <li class=svelte-1cc53ms><a href=/articles/ class="svelte-1cc53ms selected">Articles</a></li> <li class=svelte-1cc53ms><a href=https://adambar.pl/#services class=svelte-1cc53ms rel=noopener target=_blank>Services</a></li> <li class=svelte-1cc53ms><a href=https://adambar.pl/#workshops class=svelte-1cc53ms rel=noopener target=_blank>Trainings</a></li> </ul> </nav> <div class="svelte-1cc53ms title-container"> <h1 class=svelte-1cc53ms>What Web Can Do Today?</h1> <p class=svelte-1cc53ms>Can I rely on the Web Platform features to build my app?</p> <p class=svelte-1cc53ms>An overview of the device integration HTML5 APIs</p> </div> </header> <div class="svelte-nzu3si container"> <main class=svelte-nzu3si> <nav aria-label=breadcrumbs class=breadcrumb> <ul> <li><a href=/ >Features</a></li> <li><a href=/articles/ >Articles</a></li> <li class=is-active><a href=/articles/handling-service-worker-updates/ aria-current=page>Handling Service Worker updates – how to keep the app updated and stay sane</a></li> </ul> </nav> <h1>Handling Service Worker updates – how to keep the app updated and stay sane</h1> <div class="svelte-nzu3si content language-javascript"> <p>Most of the Service Worker tutorials we can find on the Web focus on the initial development efforts needed to get the <a href=/offline.html>offline mode capabilities</a> or performance gains for subsequent visits. And although it's definitely valuable for having a grasp on the advantages of employing this basic Progressive Web App building block, it's also extremely important to be aware that it's not enough. For production readiness, we need to make sure our Service Worker will be maintainable in the future. We need to have the update strategy in place not to cut off our users from actually getting the updates of our PWA.</p> <h2 id=the-update-problem>The update problem</h2> <p>Service Worker is a piece of JavaScript that works as a single controller & network proxy for all the instances of our application. That means that all the browser windows share the same active Service Worker. It has a significant consequence for the lifetime of Service Worker's code. It cannot be seamlessly updated as long as there is any window that it serves. In other words, if our users tend to forget about already opened tabs (who doesn't?) or it's in our app's nature to be opened forever (like it is for email clients, messaging apps or apps in kiosk mode, for instance), the Service Worker will be never updated, even though the browser might already have detected the pending update. </p> <p>Moreover, simple refreshing is not sufficient to make room for the new Service Worker to take over, even if there's only one tab of our application running. This is because browsers do not unload the earlier instance of the website immediately when we request the refresh – for some time the new instance being loaded exists simultaneously in the memory next to the previous one, being unloaded. So the number of windows served by the Service Worker doesn't fall down to zero in this case and the new Service Worker ready to be used can't take over. Hard-refresh (Control+Shift+R-kind) is sufficient (because it bypasses the Service Worker), but we can't expect our users to use it for the ordinary browsing.</p> <p>Not applying the Service Worker update might mean that our outdated Service Worker runs for ages and serves our users with assets from the cache that we expect to already be long-forgotten. So it's a problem not to be ignored. It's the developer's worry to make sure our app will not be "frozen in the past". And we need to ensure we have a solution in place before our first Service Worker lands on production.</p> <h2 id=first-attempt--forceful-takeover>First attempt – forceful takeover</h2> <p>Fortunately, there is a programmatic way for the waiting Service Worker (the one that we received and installed as the newly updated controller of our app) to take over control over the existing clients. We can call <code>self.skipWaiting()</code> from within the new Service Worker – it immediately stops the previously active Service Worker and activates the new one, so that all the currently opened windows will be served by the new one.</p> <p>When to call it? We may call it at the end of <code>install</code> event handling – it is what most examples on the Web do. It has a significant and often overlooked pitfall, though. All the already opened windows were loaded with the help of the previous Service Worker that potentially used different versions of the assets. Starting from the rather indeterministic point in time (possibly while the page is still being loaded), the same windows are served by the new Service Worker. Imagine what happens if our code is dynamically loaded using code-splitting or if we employ another lazy-loading techniques. Depending on the strategies we use, we might end up not being able to serve the expected asset anymore or we serve assets in incompatible version – it has a high probability of messing things up, so it's only suitable for the simplest apps, for example light on JS content websites.</p> <figure> <img alt="Diagram of partial Service Worker update cycle – attempt 1" src=/articleimgs/sw-updates-1.png> <figcaption>Diagram of partial Service Worker update cycle – attempt 1</figcaption> </figure> <h2 id=even-more-forceful-takeover>Even-more-forceful takeover</h2> <p>This technique is sometimes taken further by ensuring the app is never running in that half-old, half-new state. To avoid it, we may order all our opened windows (called <code>clients</code> in the Service Worker parlance) to refresh immediately after <code>skipWaiting</code> was called. There are at least two ways to do it – by iterating over <code>self.clients</code> from the newly-activated Service Worker and asking them to navigate to their current URLs:</p> <pre><code>// Service Worker-based solution
self.addEventListener('activate', async () => {
  // after we've taken over, iterate over all the current clients (windows)
  const tabs = await self.clients.matchAll({type: 'window'})
  tabs.forEach((tab) => {
    // ...and refresh each one of them
    tab.navigate(tab.url)
  })
})</code></pre><p>...or by listening to <code>controllerchange</code> events from the app and refreshing when it happens:</p> <pre><code>// app-based solution
let refreshing = false;

// detect controller change and refresh the page
navigator.serviceWorker.addEventListener('controllerchange', () => {
    if (!refreshing) {
        window.location.reload()
        refreshing = true
    }
})</code></pre><p>This approach solves the previous inconsistency problem, but introduces a UX challenge. Refreshing the page without any clear sign for the user might be unexpected. And what if our user was in the middle of an important operation, for example entering credit card details to pay us for our services? Seemingly random refresh might not be what we would want then.</p> <figure> <img alt="Diagram of partial Service Worker update cycle – attempt 2" src=/articleimgs/sw-updates-2.png> <figcaption>Diagram of partial Service Worker update cycle – attempt 2</figcaption> </figure> <h2 id=deferred-takeover-approach>Deferred takeover approach</h2> <p>We need to have a way to update the Service Worker and refresh without breaking the user flow. There are several approaches we can take. Which one is the right one depends on the characteristics of our app:</p> <ul> <li>it might be possible to detect a moment when the user is idle, not within any action or flow – but this kind of detection might be hard or impossible for some apps;</li> <li>we might update while transitioning between pages, if we have a Single-Page App that doesn't actually reloads between views – this is probably a moment when the active tab can be refreshed without causing harm in most apps, but what if there's an action in progress in another tab?</li> <li>finally, if we want to stay on the safe side, we might ask the user to apply the update by showing some kind of UI notification informing about the new version pending.</li> </ul> <p>What Web Can Do website updates the Service Worker and refreshes while transitioning between pages as it's rather simple and it would not be especially harmful in case someone's demo opened in another tab will get refreshed.</p> <h2 id=how-can-skipwaiting-be-deferred>How can <code>skipWaiting</code> be deferred?</h2> <p>When we already know which of the deferring strategy we'll use, we need to have a way to actually defer the update. This means, we can no longer call <code>skipWaiting</code> within <code>install</code> handler in Service Worker – we need the app to signal the Service Worker about when it's the right time to call <code>skipWaiting</code>. This in turn means the app need to know about pending Service Worker update to take action, like to wait for the user to finish the current operation or display the "new version available" notification to the user, depending what's our refresh strategy.</p> <p>The browser checks for the new Service Worker version periodically, as well as on the <code>navigator.serviceWorker.register()</code> call on every visit that happens at least 24 hours after the last Service Worker update. When the change is detected (it's a byte-by-byte content comparison), the new Service Worker is being installed (its <code>install</code> event handler is executed) as well as it is signaled to the app by <code>updatefound</code> event we can handle:</p> <pre><code>// get the ServiceWorkerRegistration instance
const registration = await navigator.serviceWorker.getRegistration();
// (it is also returned from navigator.serviceWorker.register() function)

if (registration) { // if there is a SW active
    registration.addEventListener('updatefound', () => {
        console.log('Service Worker update detected!');
    });
}</code></pre><p>So far so good. Is this handler a good place to trigger our update UX (like that "new version available" notification)? No, it's not. At this point we only know the browser detected the Service Worker file change. The new Service Worker instance is not yet ready for activation, because its <code>install</code> handler is not yet complete and it actually may fail to install, for instance when any of its network calls fail. We must wait until the new instance is ready for activation (its state is <code>installed</code>):</p> <pre><code>// our new instance is visible under installing property, because it is in 'installing' state
// let's wait until it changes its state
registration.installing.addEventListener('statechange', () => {
    if (registration.waiting) {
        // our new instance is now waiting for activation (its state is 'installed')
        // we now may invoke our update UX safely
    } else {
        // apparently installation must have failed (SW state is 'redundant')
        // it makes no sense to think about this update any more
    }
});</code></pre><p>By ensuring our update UX is only triggered when we're sure there's a Service Worker instance visible under <code>registration.waiting</code> (successfully installed, waiting for activation), we avoid running it senselessly for failed updates or too quickly, when the installation is still in progress.</p> <p>Now, the third step in this update dance is to actually signal our new Service Worker instance when the user (or our heuristic) decided it's a good time to apply the update. It's the Service Worker that needs to call <code>skipWaiting</code> and we can only communicate with it by sending it a message with <code>postMessage</code> API:</p> <pre><code>notificationBanner.addEventListener('click', () => {
    registration.waiting.postMessage('SKIP_WAITING');
});</code></pre><p>To receive the message in the Service Worker, we need to register a <code>message</code> event handler:</p> <pre><code>self.addEventListener('message', (event) => {
    if (event.data === 'SKIP_WAITING') {
        self.skipWaiting();
    });
});</code></pre><p>Given we have <code>controllerchange</code> event handler ready at the app side, as we sketched it already, sending <code>SKIP_WAITING</code> message to the new Service Worker will cause it to activate and subsequently all the tabs to refresh, removing any inconsistency risk.</p> <figure> <img alt="Diagram of full Service Worker update cycle" src=/articleimgs/sw-updates-3.png> <figcaption>Diagram of full Service Worker update cycle</figcaption> </figure> <p>Last thing to think about is what happens when the user ignores our update prompt. If we only trigger it based on <code>updatefound</code> event, we have a single window of opportunity. The solution would be to additionally check for <code>registration.waiting</code> instance existence on every page load. If we detect something there, it must mean the user ignored our update UX in one of the previous page views and we should somehow act on it (either show the prompt once again or invoke the update immediately, in case it makes sense in our app).</p> <h2 id=in-code-we-trust>In code we trust</h2> <p>Here is the full app-side code of the proposed solution, based on explicit user prompt to apply the update (note the UI notification element itself is not included):</p> <pre><code>function invokeServiceWorkerUpdateFlow(registration) {
    // TODO implement your own UI notification element
    notification.show("New version of the app is available. Refresh now?");
    notification.addEventListener('click', () => {
        if (registration.waiting) {
            // let waiting Service Worker know it should became active
            registration.waiting.postMessage('skip waiting')
        }
    })
}

// check if the browser supports serviceWorker at all
if ('serviceWorker' in navigator) {
    // wait for the page to load
    window.addEventListener('load', async () => {
        // register the service worker from the file specified
        const registration = await navigator.serviceWorker.register('/service-worker.js')

        // ensure the case when the updatefound event was missed is also handled
        // by re-invoking the prompt when there's a waiting Service Worker
        if (registration.waiting) {
            invokeServiceWorkerUpdateFlow(registration)
        }

        // detect Service Worker update available and wait for it to become installed
        registration.addEventListener('updatefound', () => {
            if (registration.installing) {
                // wait until the new Service worker is actually installed (ready to take over)
                registration.installing.addEventListener('statechange', () => {
                    if (registration.waiting) {
                        // if there's an existing controller (previous Service Worker), show the prompt
                        if (navigator.serviceWorker.controller) {
                            invokeServiceWorkerUpdateFlow(registration)
                        } else {
                            // otherwise it's the first install, nothing to do
                            console.log('Service Worker initialized for the first time')
                        }
                    }
                })
            }
        })

        let refreshing = false;

        // detect controller change and refresh the page
        navigator.serviceWorker.addEventListener('controllerchange', () => {
            if (!refreshing) {
                window.location.reload()
                refreshing = true
            }
        })
    })
}</code></pre><p>And at the Service Worker side (ensure not to have <code>self.skipWaiting()</code> call in the <code>install</code> handler):</p> <pre><code>self.addEventListener('message', (event) => {
    if (event.data === 'SKIP_WAITING') {
        self.skipWaiting();
    });
});</code></pre><h2 id=chrome-dev-tools-support>Chrome Dev Tools support</h2> <p>The whole process is quite complex and it might be extremely difficult to debug. Fortunately, Google Chrome's Dev Tools can support us here thanks to the features from Application > Service Worker section. Firstly, it nicely visualizes the states of our Service Worker instances with colored marbles. It's clearly visible when the new instance is being installed or when it's waiting for its takeover moment.</p> <figure> <img alt="Chrome Dev Tools - Application - Service Worker tab and its useful controls" src=/articleimgs/sw-updates-4.png> <figcaption>Chrome Dev Tools - Application - Service Worker tab and its useful controls</figcaption> </figure> <p>It also provides two useful buttons with self-descriptive labels: "update" forces a check for new Service Worker version, "skipWaiting" on the waiting instance activates it immediately. The real deal is with "Update on reload" switch, though. When turned on, it removes the need for the whole flow and activates the Service Worker immediately after it has been installed. This is very useful in everyday development when deferred updates and Service Worker-level caches will make the development experience pretty cumbersome. On the other hand, we need to make sure the switch is OFF when we're working on the actual flow, so that it doesn't interfere with the ordinary user flow.</p> <h2 id="">**</h2> <p>Whichever strategy of handling Service Worker updates we apply, it has its own cons and probably means the traditional trait of the ever-green Web with no need to apply updates is more or less broken. That's the unfortunate side of how Service Workers lifecycle is implemented and there's no other way than to embrace it.</p> </div> <div class="svelte-nzu3si author"><p><a href=https://adambar.pl>Adam Bar</a></p> </div> </main> <aside class=svelte-nzu3si> <h2 class=svelte-mceqtp>Advertisement</h2> <div class=ad> <script src="//cdn.carbonads.com/carbon.js?serve=CK7DT23L&placement=whatwebcandotoday" async id=_carbonads_js></script> </div> <h2 class=svelte-nzu3si>See also</h2> <div class="svelte-1itfw3h article"> <a href=/articles/opaque-responses-service-worker/ class=svelte-1itfw3h rel=prefetch> <figure> <img alt="Dealing with opaque responses in Service Worker" src=/articleimgs/phone-taking-photo-selfie.pexels.jpg class=svelte-1itfw3h loading=lazy> <figcaption class=svelte-1itfw3h>Service Worker, Offline Capabilities</figcaption> </figure> <div class="svelte-1itfw3h description"> <h3 class=svelte-1itfw3h>Dealing with opaque responses in Service Worker</h3> <p>One of the most complex and possibly annoying aspect of the offline mode implementation for Progressive Web Apps is when it needs to deal with cross-origin requests. As Service Worker is intercepting all the HTTP requests originating from our application, it means that also these reaching the external servers are to be handled, and this in turn means we need to deal with Cross-Origin Resource Sharing (CORS).</p> </div> </a> </div><div class="svelte-1itfw3h article"> <a href=/articles/progressive-web-apps-standard-or-buzzword/ class=svelte-1itfw3h rel=prefetch> <figure> <img alt="Progressive Web Apps – standard or buzzword?" src=/articleimgs/adult-books-business-coffee.pexels.jpg class=svelte-1itfw3h loading=lazy> <figcaption class=svelte-1itfw3h>PWA, Service Worker</figcaption> </figure> <div class="svelte-1itfw3h description"> <h3 class=svelte-1itfw3h>Progressive Web Apps – standard or buzzword?</h3> <p>Progressive Web Apps (PWA) is modern way to build applications, including mobile ones, using purely web technologies and relying purely on the capabilities and strengths the Web platform. Historically, it was the lack of these capabilities on the Web that caused the boom of the mobile apps, using so-called "native" (platform-specific) development approaches.</p> </div> </a> </div><div class="svelte-1itfw3h article"> <a href=/articles/use-chrome-dev-tools-switches/ class=svelte-1itfw3h rel=prefetch> <figure> <img alt="How to use Chrome Dev Tools Service Worker switches" src=/articleimgs/analogue-console-control.pexels.jpg class=svelte-1itfw3h loading=lazy> <figcaption class=svelte-1itfw3h>PWA, Service Worker</figcaption> </figure> <div class="svelte-1itfw3h description"> <h3 class=svelte-1itfw3h>How to use Chrome Dev Tools Service Worker switches</h3> <p>Google Chrome, as expected from the Service Worker API and whole Progressive Web Apps ideas main proponent, offers probably the richest developer tooling to ease the debugging, testing and experimenting with the APIs. Chrome's Dev Tools has a whole Application tab dedicated to PWA-related matters.</p> </div> </a> </div> <p class="svelte-nzu3si see-all text-center"> <a href=/articles/ class=button>See all</a> </p> </aside> </div> <div class="svelte-p0dnmz loader" aria-hidden=true> <div class="svelte-p0dnmz lds-ellipsis"> <div class=svelte-p0dnmz></div><div class=svelte-p0dnmz></div><div class=svelte-p0dnmz></div><div class=svelte-p0dnmz></div> </div> </div> <div class="svelte-btjd4g container" aria-label="Website footer"> <div class="text-center contact"> <h2 class=svelte-btjd4g>Get in touch</h2> <ul class=svelte-btjd4g> <li class=svelte-btjd4g><a href=mailto:hi@adambar.pl class="svelte-btjd4g icon mail-icon">Mail</a></li> <li class=svelte-btjd4g><a href=https://twitter.com/WhatWebCanDo class="svelte-btjd4g icon twitter-icon" rel="noreferrer noopener" target=_blank>Twitter</a></li> <li class=svelte-btjd4g><a href=https://linkedin.com/in/adamrbar class="svelte-btjd4g icon linkedin-icon" rel="noreferrer noopener" target=_blank>LinkedIn</a></li> <li class=svelte-btjd4g><a href=https://github.com/NOtherDev/whatwebcando class="svelte-btjd4g icon github-icon" rel="noreferrer noopener" target=_blank>GitHub</a></li> </ul> </div> <footer class=svelte-btjd4g role=contentinfo> <p class=text-left><a href=/privacy.html class=svelte-btjd4g>Privacy Policy</a></p> <p class=text-right> Created by <a href=https://adambar.pl class=svelte-btjd4g rel=noopener target=_blank>Adam Bar</a><br> Licenced under <a href=https://creativecommons.org/licenses/by-sa/4.0/ class=svelte-btjd4g rel="noreferrer noopener" target=_blank>CC-BY-SA 4.0</a> </p> </footer> </div></div> <script src=https://browser.sentry-cdn.com/5.12.1/bundle.min.js crossorigin=anonymous integrity=sha384-y+an4eARFKvjzOivf/Z7JtMJhaN6b+lLQ5oFbBbUwZNNVir39cYtkjW1r6Xjbxg3></script> <script>window.Sentry && Sentry.init({ dsn: 'https://f769df61d95342d7af636da1f998069c@sentry.io/1876595' });</script> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,(function(a,b,c,d,e){return {article:{title:"Handling Service Worker updates – how to keep the app updated and stay sane",slug:"handling-service-worker-updates",html:"\u003Cp\u003EMost of the Service Worker tutorials we can find on the Web focus on the initial development efforts needed to get the \u003Ca href=\"\u002Foffline.html\"\u003Eoffline mode capabilities\u003C\u002Fa\u003E or performance gains for subsequent visits. And although it&#39;s definitely valuable for having a grasp on the advantages of employing this basic Progressive Web App building block, it&#39;s also extremely important to be aware that it&#39;s not enough. For production readiness, we need to make sure our Service Worker will be maintainable in the future. We need to have the update strategy in place not to cut off our users from actually getting the updates of our PWA.\u003C\u002Fp\u003E\n\u003Ch2 id=\"the-update-problem\"\u003EThe update problem\u003C\u002Fh2\u003E\n\u003Cp\u003EService Worker is a piece of JavaScript that works as a single controller &amp; network proxy for all the instances of our application. That means that all the browser windows share the same active Service Worker. It has a significant consequence for the lifetime of Service Worker&#39;s code. It cannot be seamlessly updated as long as there is any window that it serves. In other words, if our users tend to forget about already opened tabs (who doesn&#39;t?) or it&#39;s in our app&#39;s nature to be opened forever (like it is for email clients, messaging apps or apps in kiosk mode, for instance), the Service Worker will be never updated, even though the browser might already have detected the pending update. \u003C\u002Fp\u003E\n\u003Cp\u003EMoreover, simple refreshing is not sufficient to make room for the new Service Worker to take over, even if there&#39;s only one tab of our application running. This is because browsers do not unload the earlier instance of the website immediately when we request the refresh – for some time the new instance being loaded exists simultaneously in the memory next to the previous one, being unloaded. So the number of windows served by the Service Worker doesn&#39;t fall down to zero in this case and the new Service Worker ready to be used can&#39;t take over. Hard-refresh (Control+Shift+R-kind) is sufficient (because it bypasses the Service Worker), but we can&#39;t expect our users to use it for the ordinary browsing.\u003C\u002Fp\u003E\n\u003Cp\u003ENot applying the Service Worker update might mean that our outdated Service Worker runs for ages and serves our users with assets from the cache that we expect to already be long-forgotten. So it&#39;s a problem not to be ignored. It&#39;s the developer&#39;s worry to make sure our app will not be &quot;frozen in the past&quot;. And we need to ensure we have a solution in place before our first Service Worker lands on production.\u003C\u002Fp\u003E\n\u003Ch2 id=\"first-attempt--forceful-takeover\"\u003EFirst attempt – forceful takeover\u003C\u002Fh2\u003E\n\u003Cp\u003EFortunately, there is a programmatic way for the waiting Service Worker (the one that we received and installed as the newly updated controller of our app) to take over control over the existing clients. We can call \u003Ccode\u003Eself.skipWaiting()\u003C\u002Fcode\u003E from within the new Service Worker – it immediately stops the previously active Service Worker and activates the new one, so that all the currently opened windows will be served by the new one.\u003C\u002Fp\u003E\n\u003Cp\u003EWhen to call it? We may call it at the end of \u003Ccode\u003Einstall\u003C\u002Fcode\u003E event handling – it is what most examples on the Web do. It has a significant and often overlooked pitfall, though. All the already opened windows were loaded with the help of the previous Service Worker that potentially used different versions of the assets. Starting from the rather indeterministic point in time (possibly while the page is still being loaded), the same windows are served by the new Service Worker. Imagine what happens if our code is dynamically loaded using code-splitting or if we employ another lazy-loading techniques. Depending on the strategies we use, we might end up not being able to serve the expected asset anymore or we serve assets in incompatible version – it has a high probability of messing things up, so it&#39;s only suitable for the simplest apps, for example light on JS content websites.\u003C\u002Fp\u003E\n\u003Cfigure\u003E\n  \u003Cimg src=\"\u002Farticleimgs\u002Fsw-updates-1.png\" alt=\"Diagram of partial Service Worker update cycle – attempt 1\" \u002F\u003E\n  \u003Cfigcaption\u003EDiagram of partial Service Worker update cycle – attempt 1\u003C\u002Ffigcaption\u003E\n\u003C\u002Ffigure\u003E\n\n\u003Ch2 id=\"even-more-forceful-takeover\"\u003EEven-more-forceful takeover\u003C\u002Fh2\u003E\n\u003Cp\u003EThis technique is sometimes taken further by ensuring the app is never running in that half-old, half-new state. To avoid it, we may order all our opened windows (called \u003Ccode\u003Eclients\u003C\u002Fcode\u003E in the Service Worker parlance) to refresh immediately after \u003Ccode\u003EskipWaiting\u003C\u002Fcode\u003E was called. There are at least two ways to do it – by iterating over \u003Ccode\u003Eself.clients\u003C\u002Fcode\u003E from the newly-activated Service Worker and asking them to navigate to their current URLs:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u002F\u002F Service Worker-based solution\nself.addEventListener(&#39;activate&#39;, async () =&gt; {\n  \u002F\u002F after we&#39;ve taken over, iterate over all the current clients (windows)\n  const tabs = await self.clients.matchAll({type: &#39;window&#39;})\n  tabs.forEach((tab) =&gt; {\n    \u002F\u002F ...and refresh each one of them\n    tab.navigate(tab.url)\n  })\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E...or by listening to \u003Ccode\u003Econtrollerchange\u003C\u002Fcode\u003E events from the app and refreshing when it happens:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u002F\u002F app-based solution\nlet refreshing = false;\n\n\u002F\u002F detect controller change and refresh the page\nnavigator.serviceWorker.addEventListener(&#39;controllerchange&#39;, () =&gt; {\n    if (!refreshing) {\n        window.location.reload()\n        refreshing = true\n    }\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EThis approach solves the previous inconsistency problem, but introduces a UX challenge. Refreshing the page without any clear sign for the user might be unexpected. And what if our user was in the middle of an important operation, for example entering credit card details to pay us for our services? Seemingly random refresh might not be what we would want then.\u003C\u002Fp\u003E\n\u003Cfigure\u003E\n  \u003Cimg src=\"\u002Farticleimgs\u002Fsw-updates-2.png\" alt=\"Diagram of partial Service Worker update cycle – attempt 2\" \u002F\u003E\n  \u003Cfigcaption\u003EDiagram of partial Service Worker update cycle – attempt 2\u003C\u002Ffigcaption\u003E\n\u003C\u002Ffigure\u003E\n\n\u003Ch2 id=\"deferred-takeover-approach\"\u003EDeferred takeover approach\u003C\u002Fh2\u003E\n\u003Cp\u003EWe need to have a way to update the Service Worker and refresh without breaking the user flow. There are several approaches we can take. Which one is the right one depends on the characteristics of our app:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Eit might be possible to detect a moment when the user is idle, not within any action or flow – but this kind of detection might be hard or impossible for some apps;\u003C\u002Fli\u003E\n\u003Cli\u003Ewe might update while transitioning between pages, if we have a Single-Page App that doesn&#39;t actually reloads between views – this is probably a moment when the active tab can be refreshed without causing harm in most apps, but what if there&#39;s an action in progress in another tab?\u003C\u002Fli\u003E\n\u003Cli\u003Efinally, if we want to stay on the safe side, we might ask the user to apply the update by showing some kind of UI notification informing about the new version pending.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EWhat Web Can Do website updates the Service Worker and refreshes while transitioning between pages as it&#39;s rather simple and it would not be especially harmful in case someone&#39;s demo opened in another tab will get refreshed.\u003C\u002Fp\u003E\n\u003Ch2 id=\"how-can-skipwaiting-be-deferred\"\u003EHow can \u003Ccode\u003EskipWaiting\u003C\u002Fcode\u003E be deferred?\u003C\u002Fh2\u003E\n\u003Cp\u003EWhen we already know which of the deferring strategy we&#39;ll use, we need to have a way to actually defer the update. This means, we can no longer call \u003Ccode\u003EskipWaiting\u003C\u002Fcode\u003E within \u003Ccode\u003Einstall\u003C\u002Fcode\u003E handler in Service Worker – we need the app to signal the Service Worker about when it&#39;s the right time to call \u003Ccode\u003EskipWaiting\u003C\u002Fcode\u003E. This in turn means the app need to know about pending Service Worker update to take action, like to wait for the user to finish the current operation or display the &quot;new version available&quot; notification to the user, depending what&#39;s our refresh strategy.\u003C\u002Fp\u003E\n\u003Cp\u003EThe browser checks for the new Service Worker version periodically, as well as on the \u003Ccode\u003Enavigator.serviceWorker.register()\u003C\u002Fcode\u003E call on every visit that happens at least 24 hours after the last Service Worker update. When the change is detected (it&#39;s a byte-by-byte content comparison), the new Service Worker is being installed (its \u003Ccode\u003Einstall\u003C\u002Fcode\u003E event handler is executed) as well as it is signaled to the app by \u003Ccode\u003Eupdatefound\u003C\u002Fcode\u003E event we can handle:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u002F\u002F get the ServiceWorkerRegistration instance\nconst registration = await navigator.serviceWorker.getRegistration();\n\u002F\u002F (it is also returned from navigator.serviceWorker.register() function)\n\nif (registration) { \u002F\u002F if there is a SW active\n    registration.addEventListener(&#39;updatefound&#39;, () =&gt; {\n        console.log(&#39;Service Worker update detected!&#39;);\n    });\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003ESo far so good. Is this handler a good place to trigger our update UX (like that &quot;new version available&quot; notification)? No, it&#39;s not. At this point we only know the browser detected the Service Worker file change. The new Service Worker instance is not yet ready for activation, because its \u003Ccode\u003Einstall\u003C\u002Fcode\u003E handler is not yet complete and it actually may fail to install, for instance when any of its network calls fail. We must wait until the new instance is ready for activation (its state is \u003Ccode\u003Einstalled\u003C\u002Fcode\u003E):\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u002F\u002F our new instance is visible under installing property, because it is in &#39;installing&#39; state\n\u002F\u002F let&#39;s wait until it changes its state\nregistration.installing.addEventListener(&#39;statechange&#39;, () =&gt; {\n    if (registration.waiting) {\n        \u002F\u002F our new instance is now waiting for activation (its state is &#39;installed&#39;)\n        \u002F\u002F we now may invoke our update UX safely\n    } else {\n        \u002F\u002F apparently installation must have failed (SW state is &#39;redundant&#39;)\n        \u002F\u002F it makes no sense to think about this update any more\n    }\n});\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EBy ensuring our update UX is only triggered when we&#39;re sure there&#39;s a Service Worker instance visible under \u003Ccode\u003Eregistration.waiting\u003C\u002Fcode\u003E (successfully installed, waiting for activation), we avoid running it senselessly for failed updates or too quickly, when the installation is still in progress.\u003C\u002Fp\u003E\n\u003Cp\u003ENow, the third step in this update dance is to actually signal our new Service Worker instance when the user (or our heuristic) decided it&#39;s a good time to apply the update. It&#39;s the Service Worker that needs to call \u003Ccode\u003EskipWaiting\u003C\u002Fcode\u003E and we can only communicate with it by sending it a message with \u003Ccode\u003EpostMessage\u003C\u002Fcode\u003E API:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003EnotificationBanner.addEventListener(&#39;click&#39;, () =&gt; {\n    registration.waiting.postMessage(&#39;SKIP_WAITING&#39;);\n});\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003ETo receive the message in the Service Worker, we need to register a \u003Ccode\u003Emessage\u003C\u002Fcode\u003E event handler:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Eself.addEventListener(&#39;message&#39;, (event) =&gt; {\n    if (event.data === &#39;SKIP_WAITING&#39;) {\n        self.skipWaiting();\n    });\n});\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EGiven we have \u003Ccode\u003Econtrollerchange\u003C\u002Fcode\u003E event handler ready at the app side, as we sketched it already, sending \u003Ccode\u003ESKIP_WAITING\u003C\u002Fcode\u003E message to the new Service Worker will cause it to activate and subsequently all the tabs to refresh, removing any inconsistency risk.\u003C\u002Fp\u003E\n\u003Cfigure\u003E\n  \u003Cimg src=\"\u002Farticleimgs\u002Fsw-updates-3.png\" alt=\"Diagram of full Service Worker update cycle\" \u002F\u003E\n  \u003Cfigcaption\u003EDiagram of full Service Worker update cycle\u003C\u002Ffigcaption\u003E\n\u003C\u002Ffigure\u003E\n\n\u003Cp\u003ELast thing to think about is what happens when the user ignores our update prompt. If we only trigger it based on \u003Ccode\u003Eupdatefound\u003C\u002Fcode\u003E event, we have a single window of opportunity. The solution would be to additionally check for \u003Ccode\u003Eregistration.waiting\u003C\u002Fcode\u003E instance existence on every page load. If we detect something there, it must mean the user ignored our update UX in one of the previous page views and we should somehow act on it (either show the prompt once again or invoke the update immediately, in case it makes sense in our app).\u003C\u002Fp\u003E\n\u003Ch2 id=\"in-code-we-trust\"\u003EIn code we trust\u003C\u002Fh2\u003E\n\u003Cp\u003EHere is the full app-side code of the proposed solution, based on explicit user prompt to apply the update (note the UI notification element itself is not included):\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Efunction invokeServiceWorkerUpdateFlow(registration) {\n    \u002F\u002F TODO implement your own UI notification element\n    notification.show(&quot;New version of the app is available. Refresh now?&quot;);\n    notification.addEventListener(&#39;click&#39;, () =&gt; {\n        if (registration.waiting) {\n            \u002F\u002F let waiting Service Worker know it should became active\n            registration.waiting.postMessage(&#39;skip waiting&#39;)\n        }\n    })\n}\n\n\u002F\u002F check if the browser supports serviceWorker at all\nif (&#39;serviceWorker&#39; in navigator) {\n    \u002F\u002F wait for the page to load\n    window.addEventListener(&#39;load&#39;, async () =&gt; {\n        \u002F\u002F register the service worker from the file specified\n        const registration = await navigator.serviceWorker.register(&#39;\u002Fservice-worker.js&#39;)\n\n        \u002F\u002F ensure the case when the updatefound event was missed is also handled\n        \u002F\u002F by re-invoking the prompt when there&#39;s a waiting Service Worker\n        if (registration.waiting) {\n            invokeServiceWorkerUpdateFlow(registration)\n        }\n\n        \u002F\u002F detect Service Worker update available and wait for it to become installed\n        registration.addEventListener(&#39;updatefound&#39;, () =&gt; {\n            if (registration.installing) {\n                \u002F\u002F wait until the new Service worker is actually installed (ready to take over)\n                registration.installing.addEventListener(&#39;statechange&#39;, () =&gt; {\n                    if (registration.waiting) {\n                        \u002F\u002F if there&#39;s an existing controller (previous Service Worker), show the prompt\n                        if (navigator.serviceWorker.controller) {\n                            invokeServiceWorkerUpdateFlow(registration)\n                        } else {\n                            \u002F\u002F otherwise it&#39;s the first install, nothing to do\n                            console.log(&#39;Service Worker initialized for the first time&#39;)\n                        }\n                    }\n                })\n            }\n        })\n\n        let refreshing = false;\n\n        \u002F\u002F detect controller change and refresh the page\n        navigator.serviceWorker.addEventListener(&#39;controllerchange&#39;, () =&gt; {\n            if (!refreshing) {\n                window.location.reload()\n                refreshing = true\n            }\n        })\n    })\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EAnd at the Service Worker side (ensure not to have \u003Ccode\u003Eself.skipWaiting()\u003C\u002Fcode\u003E call in the \u003Ccode\u003Einstall\u003C\u002Fcode\u003E handler):\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Eself.addEventListener(&#39;message&#39;, (event) =&gt; {\n    if (event.data === &#39;SKIP_WAITING&#39;) {\n        self.skipWaiting();\n    });\n});\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2 id=\"chrome-dev-tools-support\"\u003EChrome Dev Tools support\u003C\u002Fh2\u003E\n\u003Cp\u003EThe whole process is quite complex and it might be extremely difficult to debug. Fortunately, Google Chrome&#39;s Dev Tools can support us here thanks to the features from Application &gt; Service Worker section. Firstly, it nicely visualizes the states of our Service Worker instances with colored marbles. It&#39;s clearly visible when the new instance is being installed or when it&#39;s waiting for its takeover moment.\u003C\u002Fp\u003E\n\u003Cfigure\u003E\n  \u003Cimg src=\"\u002Farticleimgs\u002Fsw-updates-4.png\" alt=\"Chrome Dev Tools - Application - Service Worker tab and its useful controls\" \u002F\u003E\n  \u003Cfigcaption\u003EChrome Dev Tools - Application - Service Worker tab and its useful controls\u003C\u002Ffigcaption\u003E\n\u003C\u002Ffigure\u003E\n\n\u003Cp\u003EIt also provides two useful buttons with self-descriptive labels: &quot;update&quot; forces a check for new Service Worker version, &quot;skipWaiting&quot; on the waiting instance activates it immediately. The real deal is with &quot;Update on reload&quot; switch, though. When turned on, it removes the need for the whole flow and activates the Service Worker immediately after it has been installed. This is very useful in everyday development when deferred updates and Service Worker-level caches will make the development experience pretty cumbersome. On the other hand, we need to make sure the switch is OFF when we&#39;re working on the actual flow, so that it doesn&#39;t interfere with the ordinary user flow.\u003C\u002Fp\u003E\n\u003Ch2 id=\"\"\u003E**\u003C\u002Fh2\u003E\n\u003Cp\u003EWhichever strategy of handling Service Worker updates we apply, it has its own cons and probably means the traditional trait of the ever-green Web with no need to apply updates is more or less broken. That&#39;s the unfortunate side of how Service Workers lifecycle is implemented and there&#39;s no other way than to embrace it.\u003C\u002Fp\u003E\n",image:"\u002Farticleimgs\u002Ffloor-plan-on-table.pexels.jpg",tags:[a,d],description:"Most of the Service Worker tutorials we can find on the Web focus on the initial development efforts needed to get the offline mode capabilities or performance gains for subsequent visits. But for production readiness, it is not enough, though. We need to have the update strategy in place not to cut off our users from actually getting the updates of our PWA.",author:"\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fadambar.pl\"\u003EAdam Bar\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n",weight:c,source:b},otherArticles:[{title:"Dealing with opaque responses in Service Worker",slug:"opaque-responses-service-worker",image:"\u002Farticleimgs\u002Fphone-taking-photo-selfie.pexels.jpg",tags:[a,d],description:"One of the most complex and possibly annoying aspect of the offline mode implementation for Progressive Web Apps is when it needs to deal with cross-origin requests. As Service Worker is intercepting all the HTTP requests originating from our application, it means that also these reaching the external servers are to be handled, and this in turn means we need to deal with Cross-Origin Resource Sharing (CORS).",weight:1,source:b},{title:"Progressive Web Apps – standard or buzzword?",slug:"progressive-web-apps-standard-or-buzzword",image:"\u002Farticleimgs\u002Fadult-books-business-coffee.pexels.jpg",tags:[e,a],description:"Progressive Web Apps (PWA) is modern way to build applications, including mobile ones, using purely web technologies and relying purely on the capabilities and strengths the Web platform. Historically, it was the lack of these capabilities on the Web that caused the boom of the mobile apps, using so-called \"native\" (platform-specific) development approaches.",weight:c,source:b},{title:"How to use Chrome Dev Tools Service Worker switches",slug:"use-chrome-dev-tools-switches",image:"\u002Farticleimgs\u002Fanalogue-console-control.pexels.jpg",tags:[e,a],description:"Google Chrome, as expected from the Service Worker API and whole Progressive Web Apps ideas main proponent, offers probably the richest developer tooling to ease the debugging, testing and experimenting with the APIs. Chrome's Dev Tools has a whole Application tab dedicated to PWA-related matters.",weight:c,source:b}]}}("Service Worker","wwcd",2,"Offline Capabilities","PWA"))]};if('serviceWorker' in navigator) window.addEventListener('load',function(){navigator.serviceWorker.register('/service-worker.js');});(function(){try{eval("async function x(){}");var main="/client/client.dd4816db.js"}catch(e){main="/client/legacy/client.82d748ef.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> 