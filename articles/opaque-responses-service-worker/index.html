<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="Can I rely on the Web Platform features to build my app? An overview of the device integration HTML5 APIs" name=description> <meta content="width=device-width,initial-scale=1" name=viewport> <base href=/ > <link href=https://fonts.gstatic.com/s/sourcesanspro/v13/6xK3dSBYKcSV-LCoeQqfX1RYOo3qOK7lujVj9w.woff2 rel=preload type=font/woff2 as=font crossorigin=anonymous> <link href=https://fonts.gstatic.com/s/sourcesanspro/v13/6xKydSBYKcSV-LCoeQqfX1RYOo3ig4vwlxdu3cOWxw.woff2 rel=preload type=font/woff2 as=font crossorigin=anonymous> <link href=/Material-Design-Icons.woff rel=preload type=font/woff2 as=font crossorigin=anonymous> <style>@font-face{font-family:'Source Sans Pro';font-style:normal;font-weight:400;font-display:swap;src:local('Source Sans Pro Regular'),local('SourceSansPro-Regular'),url(https://fonts.gstatic.com/s/sourcesanspro/v13/6xK3dSBYKcSV-LCoeQqfX1RYOo3qOK7lujVj9w.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Source Sans Pro';font-style:normal;font-weight:700;font-display:swap;src:local('Source Sans Pro Bold'),local('SourceSansPro-Bold'),url(https://fonts.gstatic.com/s/sourcesanspro/v13/6xKydSBYKcSV-LCoeQqfX1RYOo3ig4vwlxdu3cOWxw.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:"Material Design Icons";src:url(/Material-Design-Icons.woff) format("woff");font-weight:400;font-style:normal}</style> <link href=icon-76x76.png rel=apple-touch-icon sizes="60x60 72x72 76x76"> <link href=icon-120x120.png rel=apple-touch-icon sizes="114x114 120x120"> <link href=icon-144x144.png rel=apple-touch-icon sizes=144x144> <link href=icon-152x152.png rel=apple-touch-icon sizes=152x152> <link href=icon-180x180.png rel=apple-touch-icon sizes="167x167 180x180"> <link href=icon-32x32.png rel=icon sizes="16x16 32x32" type=image/png> <link href=icon-96x96.png rel=icon sizes=96x96 type=image/png> <link href=icon-192x192.png rel=icon sizes=192x192 type=image/png> <link href=manifest.json rel=manifest> <link href=client/main.20781438.css rel=stylesheet><link href=client/[slug].379efbbb.css rel=stylesheet><link href=client/Article.528b6c68.css rel=stylesheet><link href=client/PromoBox.d1dab6ec.css rel=stylesheet><link href=client/prism.7976db51.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>What Web Can Do Today: Dealing with opaque responses in Service Worker</title> <meta content="What Web Can Do Today: Dealing with opaque responses in Service Worker" property=og:title> <meta content="One of the most complex and possibly annoying aspect of the offline mode implementation for Progressive Web Apps is when it needs to deal with cross-origin requests. As Service Worker is intercepting all the HTTP requests originating from our application, it means that also these reaching the external servers are to be handled, and this in turn means we need to deal with Cross-Origin Resource Sharing (CORS)." property=og:description> <meta content=https://whatwebcando.today//articles/opaque-responses-service-worker/ property=og:url> <meta content=https://whatwebcando.today//articleimgs/phone-taking-photo-selfie.pexels.jpg property=og:image> <meta content="What Web Can Do Today: Dealing with opaque responses in Service Worker" name=twitter:title> <meta content="One of the most complex and possibly annoying aspect of the offline mode implementation for Progressive Web Apps is when it needs to deal with cross-origin requests. As Service Worker is intercepting all the HTTP requests originating from our application, it means that also these reaching the external servers are to be handled, and this in turn means we need to deal with Cross-Origin Resource Sharing (CORS)." name=twitter:description> <meta content=https://whatwebcando.today//articleimgs/phone-taking-photo-selfie.pexels.jpg name=twitter:image><noscript id=sapper-head-end></noscript> <meta content=yes name=apple-mobile-web-app-capable> <meta content=yes name=mobile-web-app-capable> <meta content="What Web Can Do Today" name=application-name> <meta content="What Web Can Do" name=apple-mobile-web-app-title> <meta content=https://whatwebcando.today/icon-144x144.png name=msapplication-TileImage> <meta content=#ffffff name=theme-color> <meta content=#ffffff name=msapplication-navbutton-color> <meta content=black-translucent name=apple-mobile-web-app-status-bar-style> <meta content=/ name=msapplication-starturl> <meta content=website property=og:type> <meta content=WhatWebCanDo property=og:site_name> <meta content=summary name=twitter:card> <meta content=@WhatWebCanDo name=twitter:site> <meta content="ArwJxpJHLSWVBvjjQdrLQmaNmEWqwy8avXhfQz6LucaHi6E8WQqBaOblE0Z5VKA6J9kgb07nziI5EF/LmdX6+woAAABSeyJvcmlnaW4iOiJodHRwczovL3doYXR3ZWJjYW5kby50b2RheTo0NDMiLCJmZWF0dXJlIjoiV2ViTkZDIiwiZXhwaXJ5IjoxNTg2MTkzMzI1fQ==" http-equiv=origin-trial> <meta content=AvXPG1STQvEBgDH2JFiDYWH1E1Eev55sYyz+szZiCeHhwQ/VAGicjx09J1WuU2Oj5q2WRr8zZsCe7jrd+a8zTA4AAABUeyJvcmlnaW4iOiJodHRwczovL3doYXR3ZWJjYW5kby50b2RheTo0NDMiLCJmZWF0dXJlIjoiV2FrZUxvY2siLCJleHBpcnkiOjE1ODYxOTMzOTh9 http-equiv=origin-trial> <meta content=AokzD/SJeJfcKJARUtujICN14urOGYKGGlHJWE2Aixopd5YQcdCwchsqcwS84XJSX6PJTkMuabIcE1ZRZxuMzgEAAABXeyJvcmlnaW4iOiJodHRwczovL3doYXR3ZWJjYW5kby50b2RheTo0NDMiLCJmZWF0dXJlIjoiU21zUmVjZWl2ZXIiLCJleHBpcnkiOjE1ODM3NzQwODl9 http-equiv=origin-trial> </head> <body> <div id=sapper> <header class="svelte-1y3p91s text-center"> <nav> <ul class=svelte-1y3p91s> <li class=svelte-1y3p91s><a href=. class=svelte-1y3p91s>Features</a></li> <li class=svelte-1y3p91s><a href=/articles/ class="svelte-1y3p91s selected">Articles</a></li> <li class=svelte-1y3p91s><a href=https://adambar.pl/#services class=svelte-1y3p91s rel=noopener target=_blank>Services</a></li> <li class=svelte-1y3p91s><a href=https://adambar.pl/#workshops class=svelte-1y3p91s rel=noopener target=_blank>Trainings</a></li> </ul> </nav> <div class="svelte-1y3p91s title-container"> <h1 class=svelte-1y3p91s>What Web Can Do Today?</h1> <p class=svelte-1y3p91s>Can I rely on the Web Platform features to build my app?</p> <p class=svelte-1y3p91s>An overview of the device integration HTML5 APIs</p> </div> </header> <div class="svelte-nzu3si container"> <main class=svelte-nzu3si> <nav aria-label=breadcrumbs class=breadcrumb> <ul> <li><a href=/ >Features</a></li> <li><a href=/articles/ >Articles</a></li> <li class=is-active><a href=/articles/opaque-responses-service-worker/ aria-current=page>Dealing with opaque responses in Service Worker</a></li> </ul> </nav> <h1>Dealing with opaque responses in Service Worker</h1> <div class="svelte-nzu3si content language-javascript"> <p>One of the most complex and possibly annoying aspect of the <a href=https://whatwebcando.today/offline.html>offline mode</a> implementation for Progressive Web Apps is when it needs to deal with cross-origin requests, that is the requests that are issued by our application to the other, external origin. As Service Worker is intercepting all the HTTP requests originating from our application, it means that also these reaching the external servers are to be handled, and this in turn means we need to deal with <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS>Cross-Origin Resource Sharing (CORS)</a>.</p> <h2 id=how-is-cors-related-with-service-worker-caching>How is CORS related with Service Worker caching</h2> <p><img alt="Dealing with opaque responses in Service Worker" src=/articleimgs/phone-taking-photo-selfie.pexels.jpg></p> <p>Cross-Origin Resource Sharing is a safety measure implemented within the browsers to limit the risk of unwanted (potentially insecure or malicious) access to the resources from origins other than whitelisted. We can use it to protect our APIs from being used from clients we don't accept. Unless we whitelist some external domains by adding appropriate response headers in of our APIs, the browser will not allow it to call us from anywhere except our own origin. </p> <p>All cross-origin requests are affected by CORS rules, although the handling differs depending on who issued the requests. In case the request was initiated as a part of the markup, for example by <code>&lt;img src></code> attribute pointing to the image on an external server, the restriction is loosened, so that the tag receives the image without any additional server- or client-side CORS configuration, as expected. But it's not all roses – this kind of request in <a href=https://developer.mozilla.org/en-US/docs/Web/API/Request/mode>Fetch API terminology</a> has its mode set to <code>no-cors</code>. This imposes a restriction that the response for this request is not freely available to the app and may only serve to fulfil its original intent – show the image, in our case. For all other uses – like accessing it by code – it's hidden, <em>opaque</em> in the spec parlance. </p> <h2 id=how-does-opaque-response-look-like>How does <em>opaque response</em> look like?</h2> <p>From the Service Worker perspective, only the existence of the opaque response is visible. Service Worker has no access to any property of the response – not only to its <code>body</code>, but even the status (it appears as <code>0</code>, regardless if the request actually ended with <code>200</code>, <code>404</code> or any other code). This opens up a question how to approach caching these responses in Cache API.</p> <h2 id=option-1-caching-opaque-responses>Option 1: Caching opaque responses</h2> <p>Even though <code>no-cors</code> requests cause Service Worker not to have any access to the response content, it still allows us to cache it in Cache API if all we need is to speed up its loading in the future and/or allow serving it offline. We can't use <a href=https://developer.mozilla.org/en-US/docs/Web/API/Cache/add><code>cache.add</code></a> method in this case, though, as it only succeeds for responses that are <code>ok</code> (their <code>status</code> is in 200-399 range), and apparently opaque responses are never seen as <code>ok</code>, even if they succeeded (as their <code>status</code> is always <code>0</code>). We need to add these entries manually using lower-level method:</p> <pre><code>await cache.put(noCorsRequest, opaqueResponse)</code></pre><p>If we're using <a href=https://developers.google.com/web/tools/workbox/ >Workbox</a> to define our cache strategies, its default behavior excludes caching opaque responses at all. We can <a href=https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests>opt-in</a> into caching these responses by defining <code>0</code> as a valid cacheable response status.</p> <pre><code>workbox.routing.registerRoute(
  'https://example.com/image.png',
  new workbox.strategies.NetworkFirst({
    plugins: [
      new workbox.cacheableResponse.Plugin({
        statuses: [0, 200]
      })
    ]
  }),
);</code></pre><p>Caching opaque responses is a dangerous thing, though, especially if we're using <a href=https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook#cache-falling-back-to-network>Cache Falling Back To Network</a> caching strategy. We're caching the responses not knowing if they succeeded, so we also cache errors. For any cache-first strategy it would mean that once we cache the erroneous response, we're going to serve this error forever – it doesn't sound wise. For network-first strategies it has more sense, as in the worst case we'll serve the error only until we're able to reach the network again. Anyway, use this option with caution.</p> <h2 id=option-2-ignoring-opaque-responses>Option 2: Ignoring opaque responses</h2> <p>Is it then better to ignore the opaque responses? This is what Workbox does by default and this is what definitely makes sense for cache-first strategies. What we lose in this case is the ability to serve any result of the cross-origin request in offline mode, which for some apps might be a major downside.</p> <h2 id=option-3-use-full-cors>Option 3: Use full CORS</h2> <p>We can work around the problem of opaque responses by avoiding getting them in the first place. To do so, we need to ensure our requests are issued with <code>mode</code> set to <code>cors</code>. For the markup-originating resources, we may achieve it by specifying <code>crossorigin</code> attribute:</p> <pre><code>&lt;img src="https://example.com/image.png" crossorigin="anonymous" /></code></pre><p>This way we're instructing the browser to skip the loosened CORS rule for markup requests and perform full CORS validation. But it also means that our external server needs to be ready for CORS - it needs to whitelist our origin to access the image, otherwise we'll be unable to retrieve the image at all. So it's only a viable option if the server is very permissive or it's under our control and definitely not an option if the address is determined dynamically.</p> <h2 id=conclusion>Conclusion</h2> <p>Which strategy to handle opaque responses to use? Unfortunately, it's not possible to have a definite answer, It depends on the app's specifics. Generally, if we are sure the external origin whitelists our origin, we may try going with option #3. Otherwise, decide based on our caching strategy and offline needs. Prefer network-first strategies and cache the opaque response blindly (option #1) or forget about full offline support for cross-origin requests and stay on the safe side of not caching it at all (option #2).</p> </div> <div class="svelte-nzu3si author"><p><a href=https://adambar.pl>Adam Bar</a></p> </div> </main> <aside class=svelte-nzu3si> <h2 class=svelte-mceqtp>Advertisement</h2> <div class=ad> <script src="//cdn.carbonads.com/carbon.js?serve=CK7DT23L&placement=whatwebcandotoday" async id=_carbonads_js></script> </div> <h2 class=svelte-nzu3si>See also</h2> <div class="svelte-1itfw3h article"> <a href=/articles/handling-service-worker-updates/ class=svelte-1itfw3h rel=prefetch> <figure> <img alt="Handling Service Worker updates – how to keep the app updated and stay sane" src=/articleimgs/floor-plan-on-table.pexels.jpg class=svelte-1itfw3h loading=lazy> <figcaption class=svelte-1itfw3h>Service Worker, Offline Capabilities</figcaption> </figure> <div class="svelte-1itfw3h description"> <h3 class=svelte-1itfw3h>Handling Service Worker updates – how to keep the app updated and stay sane</h3> <p>Most of the Service Worker tutorials we can find on the Web focus on the initial development efforts needed to get the offline mode capabilities or performance gains for subsequent visits. But for production readiness, it is not enough, though. We need to have the update strategy in place not to cut off our users from actually getting the updates of our PWA.</p> </div> </a> </div><div class="svelte-1itfw3h article"> <a href=/articles/progressive-web-apps-standard-or-buzzword/ class=svelte-1itfw3h rel=prefetch> <figure> <img alt="Progressive Web Apps – standard or buzzword?" src=/articleimgs/adult-books-business-coffee.pexels.jpg class=svelte-1itfw3h loading=lazy> <figcaption class=svelte-1itfw3h>PWA, Service Worker</figcaption> </figure> <div class="svelte-1itfw3h description"> <h3 class=svelte-1itfw3h>Progressive Web Apps – standard or buzzword?</h3> <p>Progressive Web Apps (PWA) is modern way to build applications, including mobile ones, using purely web technologies and relying purely on the capabilities and strengths the Web platform. Historically, it was the lack of these capabilities on the Web that caused the boom of the mobile apps, using so-called "native" (platform-specific) development approaches.</p> </div> </a> </div><div class="svelte-1itfw3h article"> <a href=/articles/use-chrome-dev-tools-switches/ class=svelte-1itfw3h rel=prefetch> <figure> <img alt="How to use Chrome Dev Tools Service Worker switches" src=/articleimgs/analogue-console-control.pexels.jpg class=svelte-1itfw3h loading=lazy> <figcaption class=svelte-1itfw3h>PWA, Service Worker</figcaption> </figure> <div class="svelte-1itfw3h description"> <h3 class=svelte-1itfw3h>How to use Chrome Dev Tools Service Worker switches</h3> <p>Google Chrome, as expected from the Service Worker API and whole Progressive Web Apps ideas main proponent, offers probably the richest developer tooling to ease the debugging, testing and experimenting with the APIs. Chrome's Dev Tools has a whole Application tab dedicated to PWA-related matters.</p> </div> </a> </div> <p class="svelte-nzu3si see-all text-center"> <a href=/articles/ class=button>See all</a> </p> </aside> </div> <div class="svelte-p0dnmz loader" aria-hidden=true> <div class="svelte-p0dnmz lds-ellipsis"> <div class=svelte-p0dnmz></div><div class=svelte-p0dnmz></div><div class=svelte-p0dnmz></div><div class=svelte-p0dnmz></div> </div> </div> <div class="svelte-btjd4g container" aria-label="Website footer"> <div class="text-center contact"> <h2 class=svelte-btjd4g>Get in touch</h2> <ul class=svelte-btjd4g> <li class=svelte-btjd4g><a href=mailto:hi@adambar.pl class="svelte-btjd4g icon mail-icon">Mail</a></li> <li class=svelte-btjd4g><a href=https://twitter.com/WhatWebCanDo class="svelte-btjd4g icon twitter-icon" rel="noreferrer noopener" target=_blank>Twitter</a></li> <li class=svelte-btjd4g><a href=https://linkedin.com/in/adamrbar class="svelte-btjd4g icon linkedin-icon" rel="noreferrer noopener" target=_blank>LinkedIn</a></li> <li class=svelte-btjd4g><a href=https://github.com/NOtherDev/whatwebcando class="svelte-btjd4g icon github-icon" rel="noreferrer noopener" target=_blank>GitHub</a></li> </ul> </div> <footer class=svelte-btjd4g role=contentinfo> <p class=text-left><a href=/privacy.html class=svelte-btjd4g>Privacy Policy</a></p> <p class=text-right> Created by <a href=https://adambar.pl class=svelte-btjd4g rel=noopener target=_blank>Adam Bar</a><br> Licenced under <a href=https://creativecommons.org/licenses/by-sa/4.0/ class=svelte-btjd4g rel="noreferrer noopener" target=_blank>CC-BY-SA 4.0</a> </p> </footer> </div></div> <script src=https://browser.sentry-cdn.com/5.12.1/bundle.min.js crossorigin=anonymous integrity=sha384-y+an4eARFKvjzOivf/Z7JtMJhaN6b+lLQ5oFbBbUwZNNVir39cYtkjW1r6Xjbxg3></script> <script>window.Sentry && Sentry.init({ dsn: 'https://f769df61d95342d7af636da1f998069c@sentry.io/1876595' });</script> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,(function(a,b,c,d,e){return {article:{title:"Dealing with opaque responses in Service Worker",slug:"opaque-responses-service-worker",html:"\u003Cp\u003EOne of the most complex and possibly annoying aspect of the \u003Ca href=\"https:\u002F\u002Fwhatwebcando.today\u002Foffline.html\"\u003Eoffline mode\u003C\u002Fa\u003E implementation for Progressive Web Apps is when it needs to deal with cross-origin requests, that is the requests that are issued by our application to the other, external origin. As Service Worker is intercepting all the HTTP requests originating from our application, it means that also these reaching the external servers are to be handled, and this in turn means we need to deal with \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FHTTP\u002FCORS\"\u003ECross-Origin Resource Sharing (CORS)\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\u003Ch2 id=\"how-is-cors-related-with-service-worker-caching\"\u003EHow is CORS related with Service Worker caching\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Cimg src=\"\u002Farticleimgs\u002Fphone-taking-photo-selfie.pexels.jpg\" alt=\"Dealing with opaque responses in Service Worker\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ECross-Origin Resource Sharing is a safety measure implemented within the browsers to limit the risk of unwanted (potentially insecure or malicious) access to the resources from origins other than whitelisted. We can use it to protect our APIs from being used from clients we don&#39;t accept. Unless we whitelist some external domains by adding appropriate response headers in of our APIs, the browser will not allow it to call us from anywhere except our own origin. \u003C\u002Fp\u003E\n\u003Cp\u003EAll cross-origin requests are affected by CORS rules, although the handling differs depending on who issued the requests. In case the request was initiated as a part of the markup, for example by \u003Ccode\u003E&lt;img src&gt;\u003C\u002Fcode\u003E attribute pointing to the image on an external server, the restriction is loosened, so that the tag receives the image without any additional server- or client-side CORS configuration, as expected. But it&#39;s not all roses – this kind of request in \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FRequest\u002Fmode\"\u003EFetch API terminology\u003C\u002Fa\u003E has its mode set to \u003Ccode\u003Eno-cors\u003C\u002Fcode\u003E. This imposes a restriction that the response for this request is not freely available to the app and may only serve to fulfil its original intent – show the image, in our case. For all other uses – like accessing it by code – it&#39;s hidden, \u003Cem\u003Eopaque\u003C\u002Fem\u003E in the spec parlance. \u003C\u002Fp\u003E\n\u003Ch2 id=\"how-does-opaque-response-look-like\"\u003EHow does \u003Cem\u003Eopaque response\u003C\u002Fem\u003E look like?\u003C\u002Fh2\u003E\n\u003Cp\u003EFrom the Service Worker perspective, only the existence of the opaque response is visible. Service Worker has no access to any property of the response – not only to its \u003Ccode\u003Ebody\u003C\u002Fcode\u003E, but even the status (it appears as \u003Ccode\u003E0\u003C\u002Fcode\u003E, regardless if the request actually ended with \u003Ccode\u003E200\u003C\u002Fcode\u003E, \u003Ccode\u003E404\u003C\u002Fcode\u003E or any other code). This opens up a question how to approach caching these responses in Cache API.\u003C\u002Fp\u003E\n\u003Ch2 id=\"option-1-caching-opaque-responses\"\u003EOption 1: Caching opaque responses\u003C\u002Fh2\u003E\n\u003Cp\u003EEven though \u003Ccode\u003Eno-cors\u003C\u002Fcode\u003E requests cause Service Worker not to have any access to the response content, it still allows us to cache it in Cache API if all we need is to speed up its loading in the future and\u002For allow serving it offline. We can&#39;t use \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FCache\u002Fadd\"\u003E\u003Ccode\u003Ecache.add\u003C\u002Fcode\u003E\u003C\u002Fa\u003E method in this case, though, as it only succeeds for responses that are \u003Ccode\u003Eok\u003C\u002Fcode\u003E (their \u003Ccode\u003Estatus\u003C\u002Fcode\u003E is in 200-399 range), and apparently opaque responses are never seen as \u003Ccode\u003Eok\u003C\u002Fcode\u003E, even if they succeeded (as their \u003Ccode\u003Estatus\u003C\u002Fcode\u003E is always \u003Ccode\u003E0\u003C\u002Fcode\u003E). We need to add these entries manually using lower-level method:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Eawait cache.put(noCorsRequest, opaqueResponse)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EIf we&#39;re using \u003Ca href=\"https:\u002F\u002Fdevelopers.google.com\u002Fweb\u002Ftools\u002Fworkbox\u002F\"\u003EWorkbox\u003C\u002Fa\u003E to define our cache strategies, its default behavior excludes caching opaque responses at all. We can \u003Ca href=\"https:\u002F\u002Fdevelopers.google.com\u002Fweb\u002Ftools\u002Fworkbox\u002Fguides\u002Fhandle-third-party-requests\"\u003Eopt-in\u003C\u002Fa\u003E into caching these responses by defining \u003Ccode\u003E0\u003C\u002Fcode\u003E as a valid cacheable response status.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Eworkbox.routing.registerRoute(\n  &#39;https:\u002F\u002Fexample.com\u002Fimage.png&#39;,\n  new workbox.strategies.NetworkFirst({\n    plugins: [\n      new workbox.cacheableResponse.Plugin({\n        statuses: [0, 200]\n      })\n    ]\n  }),\n);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003ECaching opaque responses is a dangerous thing, though, especially if we&#39;re using \u003Ca href=\"https:\u002F\u002Fdevelopers.google.com\u002Fweb\u002Ffundamentals\u002Finstant-and-offline\u002Foffline-cookbook#cache-falling-back-to-network\"\u003ECache Falling Back To Network\u003C\u002Fa\u003E caching strategy. We&#39;re caching the responses not knowing if they succeeded, so we also cache errors. For any cache-first strategy it would mean that once we cache the erroneous response, we&#39;re going to serve this error forever – it doesn&#39;t sound wise. For network-first strategies it has more sense, as in the worst case we&#39;ll serve the error only until we&#39;re able to reach the network again. Anyway, use this option with caution.\u003C\u002Fp\u003E\n\u003Ch2 id=\"option-2-ignoring-opaque-responses\"\u003EOption 2: Ignoring opaque responses\u003C\u002Fh2\u003E\n\u003Cp\u003EIs it then better to ignore the opaque responses? This is what Workbox does by default and this is what definitely makes sense for cache-first strategies. What we lose in this case is the ability to serve any result of the cross-origin request in offline mode, which for some apps might be a major downside.\u003C\u002Fp\u003E\n\u003Ch2 id=\"option-3-use-full-cors\"\u003EOption 3: Use full CORS\u003C\u002Fh2\u003E\n\u003Cp\u003EWe can work around the problem of opaque responses by avoiding getting them in the first place. To do so, we need to ensure our requests are issued with \u003Ccode\u003Emode\u003C\u002Fcode\u003E set to \u003Ccode\u003Ecors\u003C\u002Fcode\u003E. For the markup-originating resources, we may achieve it by specifying \u003Ccode\u003Ecrossorigin\u003C\u002Fcode\u003E attribute:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E&lt;img src=&quot;https:\u002F\u002Fexample.com\u002Fimage.png&quot; crossorigin=&quot;anonymous&quot; \u002F&gt;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EThis way we&#39;re instructing the browser to skip the loosened CORS rule for markup requests and perform full CORS validation. But it also means that our external server needs to be ready for CORS - it needs to whitelist our origin to access the image, otherwise we&#39;ll be unable to retrieve the image at all. So it&#39;s only a viable option if the server is very permissive or it&#39;s under our control and definitely not an option if the address is determined dynamically.\u003C\u002Fp\u003E\n\u003Ch2 id=\"conclusion\"\u003EConclusion\u003C\u002Fh2\u003E\n\u003Cp\u003EWhich strategy to handle opaque responses to use? Unfortunately, it&#39;s not possible to have a definite answer, It depends on the app&#39;s specifics. Generally, if we are sure the external origin whitelists our origin, we may try going with option #3. Otherwise, decide based on our caching strategy and offline needs. Prefer network-first strategies and cache the opaque response blindly (option #1) or forget about full offline support for cross-origin requests and stay on the safe side of not caching it at all (option #2).\u003C\u002Fp\u003E\n",image:"\u002Farticleimgs\u002Fphone-taking-photo-selfie.pexels.jpg",tags:[a,d],description:"One of the most complex and possibly annoying aspect of the offline mode implementation for Progressive Web Apps is when it needs to deal with cross-origin requests. As Service Worker is intercepting all the HTTP requests originating from our application, it means that also these reaching the external servers are to be handled, and this in turn means we need to deal with Cross-Origin Resource Sharing (CORS).",author:"\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fadambar.pl\"\u003EAdam Bar\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n",weight:1,source:b},otherArticles:[{title:"Handling Service Worker updates – how to keep the app updated and stay sane",slug:"handling-service-worker-updates",image:"\u002Farticleimgs\u002Ffloor-plan-on-table.pexels.jpg",tags:[a,d],description:"Most of the Service Worker tutorials we can find on the Web focus on the initial development efforts needed to get the offline mode capabilities or performance gains for subsequent visits. But for production readiness, it is not enough, though. We need to have the update strategy in place not to cut off our users from actually getting the updates of our PWA.",weight:c,source:b},{title:"Progressive Web Apps – standard or buzzword?",slug:"progressive-web-apps-standard-or-buzzword",image:"\u002Farticleimgs\u002Fadult-books-business-coffee.pexels.jpg",tags:[e,a],description:"Progressive Web Apps (PWA) is modern way to build applications, including mobile ones, using purely web technologies and relying purely on the capabilities and strengths the Web platform. Historically, it was the lack of these capabilities on the Web that caused the boom of the mobile apps, using so-called \"native\" (platform-specific) development approaches.",weight:c,source:b},{title:"How to use Chrome Dev Tools Service Worker switches",slug:"use-chrome-dev-tools-switches",image:"\u002Farticleimgs\u002Fanalogue-console-control.pexels.jpg",tags:[e,a],description:"Google Chrome, as expected from the Service Worker API and whole Progressive Web Apps ideas main proponent, offers probably the richest developer tooling to ease the debugging, testing and experimenting with the APIs. Chrome's Dev Tools has a whole Application tab dedicated to PWA-related matters.",weight:c,source:b}]}}("Service Worker","wwcd",2,"Offline Capabilities","PWA"))]};if('serviceWorker' in navigator) window.addEventListener('load',function(){navigator.serviceWorker.register('/service-worker.js');});(function(){try{eval("async function x(){}");var main="/client/client.19943092.js"}catch(e){main="/client/legacy/client.a78ef8c6.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> 