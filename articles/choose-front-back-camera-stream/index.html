<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="Can I rely on the Web Platform features to build my app? An overview of the device integration HTML5 APIs" name=description> <meta content="width=device-width,initial-scale=1" name=viewport> <base href=/ > <link href=https://fonts.gstatic.com/s/sourcesanspro/v13/6xK3dSBYKcSV-LCoeQqfX1RYOo3qOK7lujVj9w.woff2 rel=preload type=font/woff2 as=font crossorigin=anonymous> <link href=https://fonts.gstatic.com/s/sourcesanspro/v13/6xKydSBYKcSV-LCoeQqfX1RYOo3ig4vwlxdu3cOWxw.woff2 rel=preload type=font/woff2 as=font crossorigin=anonymous> <link href=/Material-Design-Icons.woff rel=preload type=font/woff2 as=font crossorigin=anonymous> <style>@font-face{font-family:'Source Sans Pro';font-style:normal;font-weight:400;font-display:swap;src:local('Source Sans Pro Regular'),local('SourceSansPro-Regular'),url(https://fonts.gstatic.com/s/sourcesanspro/v13/6xK3dSBYKcSV-LCoeQqfX1RYOo3qOK7lujVj9w.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Source Sans Pro';font-style:normal;font-weight:700;font-display:swap;src:local('Source Sans Pro Bold'),local('SourceSansPro-Bold'),url(https://fonts.gstatic.com/s/sourcesanspro/v13/6xKydSBYKcSV-LCoeQqfX1RYOo3ig4vwlxdu3cOWxw.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:"Material Design Icons";src:url(/Material-Design-Icons.woff) format("woff");font-weight:400;font-style:normal}</style> <link href=icon-76x76.png rel=apple-touch-icon sizes="60x60 72x72 76x76"> <link href=icon-120x120.png rel=apple-touch-icon sizes="114x114 120x120"> <link href=icon-144x144.png rel=apple-touch-icon sizes=144x144> <link href=icon-152x152.png rel=apple-touch-icon sizes=152x152> <link href=icon-180x180.png rel=apple-touch-icon sizes="167x167 180x180"> <link href=icon-32x32.png rel=icon sizes="16x16 32x32" type=image/png> <link href=icon-96x96.png rel=icon sizes=96x96 type=image/png> <link href=icon-192x192.png rel=icon sizes=192x192 type=image/png> <link href=manifest.json rel=manifest> <link href=client/main.981014900.css rel=stylesheet><link href=client/[slug].657368e0.css rel=stylesheet><link href=client/Article.15023632.css rel=stylesheet><link href=client/PromoBox.ad64a895.css rel=stylesheet><link href=client/prism.7976db51.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>What Web Can Do Today: How to choose between front and back camera stream</title> <meta content="What Web Can Do Today: How to choose between front and back camera stream" property=og:title> <meta content="Most of the browsers nowadays, including mobile browsers, allow the applications to retrieve and use the data stream coming directly from the user's device camera. But it's very common for the devices nowadays to have more than one camera available and we might have a preference which of these cameras is better suited for our app's needs. Fortunately, the Media Stream API has us covered." property=og:description> <meta content=https://whatwebcando.today//articles/choose-front-back-camera-stream/ property=og:url> <meta content=https://whatwebcando.today//articleimgs/black-camera-mounted-on-tripod.pexels.jpg property=og:image> <meta content="What Web Can Do Today: How to choose between front and back camera stream" name=twitter:title> <meta content="Most of the browsers nowadays, including mobile browsers, allow the applications to retrieve and use the data stream coming directly from the user's device camera. But it's very common for the devices nowadays to have more than one camera available and we might have a preference which of these cameras is better suited for our app's needs. Fortunately, the Media Stream API has us covered." name=twitter:description> <meta content=https://whatwebcando.today//articleimgs/black-camera-mounted-on-tripod.pexels.jpg name=twitter:image><noscript id=sapper-head-end></noscript> <meta content=yes name=apple-mobile-web-app-capable> <meta content=yes name=mobile-web-app-capable> <meta content="What Web Can Do Today" name=application-name> <meta content="What Web Can Do" name=apple-mobile-web-app-title> <meta content=https://whatwebcando.today/icon-144x144.png name=msapplication-TileImage> <meta content=#ffffff name=theme-color> <meta content=#ffffff name=msapplication-navbutton-color> <meta content=black-translucent name=apple-mobile-web-app-status-bar-style> <meta content=/ name=msapplication-starturl> <meta content=website property=og:type> <meta content=WhatWebCanDo property=og:site_name> <meta content=summary name=twitter:card> <meta content=@WhatWebCanDo name=twitter:site> <meta content="ArwJxpJHLSWVBvjjQdrLQmaNmEWqwy8avXhfQz6LucaHi6E8WQqBaOblE0Z5VKA6J9kgb07nziI5EF/LmdX6+woAAABSeyJvcmlnaW4iOiJodHRwczovL3doYXR3ZWJjYW5kby50b2RheTo0NDMiLCJmZWF0dXJlIjoiV2ViTkZDIiwiZXhwaXJ5IjoxNTg2MTkzMzI1fQ==" http-equiv=origin-trial> <meta content=AvXPG1STQvEBgDH2JFiDYWH1E1Eev55sYyz+szZiCeHhwQ/VAGicjx09J1WuU2Oj5q2WRr8zZsCe7jrd+a8zTA4AAABUeyJvcmlnaW4iOiJodHRwczovL3doYXR3ZWJjYW5kby50b2RheTo0NDMiLCJmZWF0dXJlIjoiV2FrZUxvY2siLCJleHBpcnkiOjE1ODYxOTMzOTh9 http-equiv=origin-trial> <meta content=AokzD/SJeJfcKJARUtujICN14urOGYKGGlHJWE2Aixopd5YQcdCwchsqcwS84XJSX6PJTkMuabIcE1ZRZxuMzgEAAABXeyJvcmlnaW4iOiJodHRwczovL3doYXR3ZWJjYW5kby50b2RheTo0NDMiLCJmZWF0dXJlIjoiU21zUmVjZWl2ZXIiLCJleHBpcnkiOjE1ODM3NzQwODl9 http-equiv=origin-trial> <meta content=AkFCG08Zf0cVbOTjoMNOXQW/DP/Gwg4ZAdNG4Z+5fcjAI4XHor6CzKgjvfSZz3v6iPS0iYwtySnCA7gx3lxVYwoAAABgeyJvcmlnaW4iOiJodHRwczovL3doYXR3ZWJjYW5kby50b2RheTo0NDMiLCJmZWF0dXJlIjoiTm90aWZpY2F0aW9uVHJpZ2dlcnMiLCJleHBpcnkiOjE1ODgzNDI5NDF9 http-equiv=origin-trial> <meta content="ArRrjcoY5Bw1puR1fodEH/J2dLGJMDplD3pNEFMUu/4QSX5pN7c2F5PIESM3fm6TEMS66gKL8Do2xgwZau4AGQ0AAABceyJvcmlnaW4iOiJodHRwczovL3doYXR3ZWJjYW5kby50b2RheTo0NDMiLCJmZWF0dXJlIjoiTmF0aXZlRmlsZVN5c3RlbSIsImV4cGlyeSI6MTU4ODYyNzE2N30=" http-equiv=origin-trial> <meta content="Ari9ohrIpr5NHKVIqGkH3WT8kXq2nYixTXrCCmZW8pfcBY+CILXUzh4LbT6LnDBV9qAcZDq+9d7Xt0SHugdmrg4AAABVeyJvcmlnaW4iOiJodHRwczovL3doYXR3ZWJjYW5kby50b2RheTo0NDMiLCJmZWF0dXJlIjoiQmFkZ2luZ1YyIiwiZXhwaXJ5IjoxNjAwMjE0Mzk5fQ==" http-equiv=origin-trial> </head> <body> <div id=sapper> <header class="svelte-1cc53ms text-center"> <nav> <ul class=svelte-1cc53ms> <li class=svelte-1cc53ms><a href=. class=svelte-1cc53ms>Features</a></li> <li class=svelte-1cc53ms><a href=/articles/ class="svelte-1cc53ms selected">Articles</a></li> <li class=svelte-1cc53ms><a href=https://adambar.pl/#services class=svelte-1cc53ms rel=noopener target=_blank>Services</a></li> <li class=svelte-1cc53ms><a href=https://adambar.pl/#workshops class=svelte-1cc53ms rel=noopener target=_blank>Trainings</a></li> </ul> </nav> <div class="svelte-1cc53ms title-container"> <h1 class=svelte-1cc53ms>What Web Can Do Today?</h1> <p class=svelte-1cc53ms>Can I rely on the Web Platform features to build my app?</p> <p class=svelte-1cc53ms>An overview of the device integration HTML5 APIs</p> </div> </header> <div class="svelte-nzu3si container"> <main class=svelte-nzu3si> <nav aria-label=breadcrumbs class=breadcrumb> <ul> <li><a href=/ >Features</a></li> <li><a href=/articles/ >Articles</a></li> <li class=is-active><a href=/articles/choose-front-back-camera-stream/ aria-current=page>How to choose between front and back camera stream</a></li> </ul> </nav> <h1>How to choose between front and back camera stream</h1> <div class="svelte-nzu3si content language-javascript"> <p><a href="https://caniuse.com/#feat=stream">Most of the browsers nowadays</a>, including mobile browsers, allow the applications to retrieve and use the data stream coming directly from the user's device camera. But it's very common for the devices nowadays to have more than one camera available and we might have a preference which of these cameras is better suited for our app's needs. Fortunately, the <a href=https://developer.mozilla.org/en-US/docs/Web/API/Media_Streams_API>Media Stream API</a> has us covered.</p> <h2 id=media-stream-api>Media Stream API</h2> <p>Let's first remind ourselves how do we access the video stream from the user's camera at all. The API sits in <code>navigator.mediaDevices</code> and is generic in terms of what kind of media stream it serves. We must specify. that we're particularly interested in video stream. This selects the proper device as well as displays the informative permission prompt for the user. If we requested video only, the browser will ask for a camera access. If we also wants audio, the prompt will include both camera and microphone.</p> <figure> <img alt="Chrome's permissions dialog for video and audio stream" src=/articleimgs/camera-permissions.png> <figcaption>Chrome's permissions dialog for video and audio stream</figcaption> </figure> <pre><code>const stream = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: true
})</code></pre><p>The API is asynchronous – we'll get the stream when the user accepts the prompt and the browser finds the proper devices. If any of these fail, our Promise will get rejected.</p> <p>In case we successfully acquired the stream, we can start manipulating it. The simplest thing we can do with it is to redirect it to a <code>&lt;video></code> element. In most cases, the <code>&lt;video></code> element has its source specified as a static file, but it also can have any stream as its source – including the one we get from the user's device. We need to attach it programatically:</p> <pre><code>const video = document.querySelector('video');
video.srcObject = stream;
video.play();</code></pre><p>Now, our <code>&lt;video></code> element will transmit the stream from the camera. So if the front camera is in use it will act as a mirror. But how do we ensure the proper one is used?</p> <h2 id=selecting-facing-mode-of-the-video-stream>Selecting facing mode of the video stream</h2> <p>When we were acquiring the stream, we passed an object as a <code>getUserMedia</code> parameter. This object is a stream constraint definition. We only constrained the stream to include video (and audio) so far. But we can apply tighter constraint:</p> <pre><code>const stream = await navigator.mediaDevices.getUserMedia({
    video: {
        facingMode: 'user'
    }
})</code></pre><p>Here, we put an object including <code>facingMode</code> property as a video constraint, instead of simple <code>true</code> that accepted any kind of video input. With constraint, we suggest the browser for what kind of video stream it should look for. In the example, we set it to <code>user</code>-facing camera – a.k.a. selfie camera, or the front one. Alternatively, we can specify we want to face <code>environment</code>, which is what is observed by the back camera.</p> <p>The constraint set this way only works as a suggestion, though – in case we run this code on a device equipped with back camera only, we'd get the environment-facing stream anyway, as it's the only one available and it's still better to use whatever we have available instead of failing in most scenarios. But if our requirement is strict and we need to use the front camera or no camera, we can set an additional constraint using <code>exact</code>:</p> <pre><code>const stream = await navigator.mediaDevices.getUserMedia({
    video: {
        facingMode: {
            exact: 'user'
        }
    }
})</code></pre><p>Now, if the device only has an environment-facing camera, we'd not get any stream and the Promise will be rejected with <code>OverconstrainedError</code>.</p> <h2 id=more-constraints>More constraints</h2> <p>Facing mode is not the only constraint specified by the Media Stream API. We may see the full list of constraint options using <code>navigator.mediaDevices.getSupportedConstraints()</code> call. And this list might be quite impressive. This is what Chrome 80 on macOS lists as available:</p> <pre><code>{
    aspectRatio: true
    autoGainControl: true
    brightness: true
    channelCount: true
    colorTemperature: true
    contrast: true
    deviceId: true
    echoCancellation: true
    exposureCompensation: true
    exposureMode: true
    exposureTime: true
    facingMode: true
    focusDistance: true
    focusMode: true
    frameRate: true
    groupId: true
    height: true
    iso: true
    latency: true
    noiseSuppression: true
    pointsOfInterest: true
    resizeMode: true
    sampleRate: true
    sampleSize: true
    saturation: true
    sharpness: true
    torch: true
    whiteBalanceMode: true
    width: true
    zoom: true
    videoKind: true
    pan: true
    tilt: true
}</code></pre><p>Obviously, some of these constraint only make sense for audio and others for video streams.</p> <p>The ones that might also be frequently used are these related with video resolution:</p> <pre><code>const stream = await navigator.mediaDevices.getUserMedia({
    video: {
        width: 1280,
        height: 720
    }
})</code></pre><p>Note that like with <code>facingMode</code>, by default this is only a suggestion for what kind of stream we are looking for and the browser might as well provide the one with different size. We might again use <code>exact</code> modifier to ask for exactly the size specified, but in case of resolution it's probably wiser to specify the minimum size we accept, using <code>min</code> modifier:</p> <pre><code>const stream = await navigator.mediaDevices.getUserMedia({
    video: {
        width: {
            min: 1280
        },
        height: {
            min: 720
        }
    }
})</code></pre><p>The browser now will not provide a stream if it's not possible to find one with at least 1280x720 size.</p> <h2 id=selecting-both-size-and-facing-mode>Selecting both size and facing mode</h2> <p>As the constraint is an object, nothing stops us from specifying more requirements, possibly with different modifiers. The browser will try to match as many as possible when providing the stream and in case we used <code>exact</code> or <code>min</code> modifiers that can't be satisfied, it will again reject the promise with <code>OverconstrainedError</code>.</p> <pre><code>const stream = await navigator.mediaDevices.getUserMedia({
    video: {
        facingMode: 'environment',
        width: {
            min: 1280
        },
        height: {
            min: 720
        }
    }
})</code></pre><p>In this example, we're asking for the stream that should face the environment (back camera) when possible, but we also accept if only the front camera is available. For size we do not accept the sizes smaller than 1280 in width or 720 in height.</p> </div> <div class="svelte-nzu3si author"><p><a href=https://adambar.pl>Adam Bar</a></p> </div> </main> <aside class=svelte-nzu3si> <h2 class=svelte-mceqtp>Advertisement</h2> <div class=ad> <script src="//cdn.carbonads.com/carbon.js?serve=CK7DT23L&placement=whatwebcandotoday" async id=_carbonads_js></script> </div> <h2 class=svelte-nzu3si>See also</h2> <div class="svelte-1itfw3h article"> <a href=https://pwafire.org/developer/docs/a-good-push-notification/ class=svelte-1itfw3h rel=noopener target=_blank> <figure> <img alt="A Good Push Notification" src=/articleimgs/letter-envelopes.pexels.jpg class=svelte-1itfw3h loading=lazy> <figcaption class=svelte-1itfw3h>Push Notifications</figcaption> </figure> <div class="svelte-1itfw3h description"> <h3 class=svelte-1itfw3h>A Good Push Notification</h3> <p>What makes a good Push Notifcation? Get tips to help you push value to your users and not users away.</p> <p class="svelte-1itfw3h source">Article by pwafire.org</p> </div> </a> </div><div class="svelte-1itfw3h article"> <a href=/articles/handling-service-worker-updates/ class=svelte-1itfw3h rel=prefetch> <figure> <img alt="Handling Service Worker updates – how to keep the app updated and stay sane" src=/articleimgs/floor-plan-on-table.pexels.jpg class=svelte-1itfw3h loading=lazy> <figcaption class=svelte-1itfw3h>Service Worker, Offline Capabilities</figcaption> </figure> <div class="svelte-1itfw3h description"> <h3 class=svelte-1itfw3h>Handling Service Worker updates – how to keep the app updated and stay sane</h3> <p>Most of the Service Worker tutorials we can find on the Web focus on the initial development efforts needed to get the offline mode capabilities or performance gains for subsequent visits. But for production readiness, it is not enough, though. We need to have the update strategy in place not to cut off our users from actually getting the updates of our PWA.</p> </div> </a> </div><div class="svelte-1itfw3h article"> <a href=/articles/progressive-web-apps-standard-or-buzzword/ class=svelte-1itfw3h rel=prefetch> <figure> <img alt="Progressive Web Apps – standard or buzzword?" src=/articleimgs/adult-books-business-coffee.pexels.jpg class=svelte-1itfw3h loading=lazy> <figcaption class=svelte-1itfw3h>PWA, Service Worker</figcaption> </figure> <div class="svelte-1itfw3h description"> <h3 class=svelte-1itfw3h>Progressive Web Apps – standard or buzzword?</h3> <p>Progressive Web Apps (PWA) is modern way to build applications, including mobile ones, using purely web technologies and relying purely on the capabilities and strengths the Web platform. Historically, it was the lack of these capabilities on the Web that caused the boom of the mobile apps, using so-called "native" (platform-specific) development approaches.</p> </div> </a> </div> <p class="svelte-nzu3si see-all text-center"> <a href=/articles/ class=button>See all</a> </p> </aside> </div> <div class="svelte-p0dnmz loader" aria-hidden=true> <div class="svelte-p0dnmz lds-ellipsis"> <div class=svelte-p0dnmz></div><div class=svelte-p0dnmz></div><div class=svelte-p0dnmz></div><div class=svelte-p0dnmz></div> </div> </div> <div class="svelte-btjd4g container" aria-label="Website footer"> <div class="text-center contact"> <h2 class=svelte-btjd4g>Get in touch</h2> <ul class=svelte-btjd4g> <li class=svelte-btjd4g><a href=mailto:hi@adambar.pl class="svelte-btjd4g icon mail-icon">Mail</a></li> <li class=svelte-btjd4g><a href=https://twitter.com/WhatWebCanDo class="svelte-btjd4g icon twitter-icon" rel="noreferrer noopener" target=_blank>Twitter</a></li> <li class=svelte-btjd4g><a href=https://linkedin.com/in/adamrbar class="svelte-btjd4g icon linkedin-icon" rel="noreferrer noopener" target=_blank>LinkedIn</a></li> <li class=svelte-btjd4g><a href=https://github.com/NOtherDev/whatwebcando class="svelte-btjd4g icon github-icon" rel="noreferrer noopener" target=_blank>GitHub</a></li> </ul> </div> <footer class=svelte-btjd4g role=contentinfo> <p class=text-left><a href=/privacy.html class=svelte-btjd4g>Privacy Policy</a></p> <p class=text-right> Created by <a href=https://adambar.pl class=svelte-btjd4g rel=noopener target=_blank>Adam Bar</a><br> Licenced under <a href=https://creativecommons.org/licenses/by-sa/4.0/ class=svelte-btjd4g rel="noreferrer noopener" target=_blank>CC-BY-SA 4.0</a> </p> </footer> </div></div> <script src=https://browser.sentry-cdn.com/5.12.1/bundle.min.js crossorigin=anonymous integrity=sha384-y+an4eARFKvjzOivf/Z7JtMJhaN6b+lLQ5oFbBbUwZNNVir39cYtkjW1r6Xjbxg3></script> <script>window.Sentry && Sentry.init({ dsn: 'https://f769df61d95342d7af636da1f998069c@sentry.io/1876595' });</script> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,(function(a,b,c){return {article:{title:"How to choose between front and back camera stream",slug:"choose-front-back-camera-stream",html:"\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fcaniuse.com\u002F#feat=stream\"\u003EMost of the browsers nowadays\u003C\u002Fa\u003E, including mobile browsers, allow the applications to retrieve and use the data stream coming directly from the user&#39;s device camera. But it&#39;s very common for the devices nowadays to have more than one camera available and we might have a preference which of these cameras is better suited for our app&#39;s needs. Fortunately, the \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FMedia_Streams_API\"\u003EMedia Stream API\u003C\u002Fa\u003E has us covered.\u003C\u002Fp\u003E\n\u003Ch2 id=\"media-stream-api\"\u003EMedia Stream API\u003C\u002Fh2\u003E\n\u003Cp\u003ELet&#39;s first remind ourselves how do we access the video stream from the user&#39;s camera at all. The API sits in \u003Ccode\u003Enavigator.mediaDevices\u003C\u002Fcode\u003E and is generic in terms of what kind of media stream it serves. We must specify. that we&#39;re particularly interested in video stream. This selects the proper device as well as displays the informative permission prompt for the user. If we requested video only, the browser will ask for a camera access. If we also wants audio, the prompt will include both camera and microphone.\u003C\u002Fp\u003E\n\u003Cfigure\u003E\n  \u003Cimg src=\"\u002Farticleimgs\u002Fcamera-permissions.png\" alt=\"Chrome's permissions dialog for video and audio stream\" \u002F\u003E\n  \u003Cfigcaption\u003EChrome's permissions dialog for video and audio stream\u003C\u002Ffigcaption\u003E\n\u003C\u002Ffigure\u003E\n\n\u003Cpre\u003E\u003Ccode\u003Econst stream = await navigator.mediaDevices.getUserMedia({\n    video: true,\n    audio: true\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EThe API is asynchronous – we&#39;ll get the stream when the user accepts the prompt and the browser finds the proper devices. If any of these fail, our Promise will get rejected.\u003C\u002Fp\u003E\n\u003Cp\u003EIn case we successfully acquired the stream, we can start manipulating it. The simplest thing we can do with it is to redirect it to a \u003Ccode\u003E&lt;video&gt;\u003C\u002Fcode\u003E element. In most cases, the \u003Ccode\u003E&lt;video&gt;\u003C\u002Fcode\u003E element has its source specified as a static file, but it also can have any stream as its source – including the one we get from the user&#39;s device. We need to attach it programatically:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Econst video = document.querySelector(&#39;video&#39;);\nvideo.srcObject = stream;\nvideo.play();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003ENow, our \u003Ccode\u003E&lt;video&gt;\u003C\u002Fcode\u003E element will transmit the stream from the camera. So if the front camera is in use it will act as a mirror. But how do we ensure the proper one is used?\u003C\u002Fp\u003E\n\u003Ch2 id=\"selecting-facing-mode-of-the-video-stream\"\u003ESelecting facing mode of the video stream\u003C\u002Fh2\u003E\n\u003Cp\u003EWhen we were acquiring the stream, we passed an object as a \u003Ccode\u003EgetUserMedia\u003C\u002Fcode\u003E parameter. This object is a stream constraint definition. We only constrained the stream to include video (and audio) so far. But we can apply tighter constraint:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Econst stream = await navigator.mediaDevices.getUserMedia({\n    video: {\n        facingMode: &#39;user&#39;\n    }\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EHere, we put an object including \u003Ccode\u003EfacingMode\u003C\u002Fcode\u003E property as a video constraint, instead of simple \u003Ccode\u003Etrue\u003C\u002Fcode\u003E that accepted any kind of video input. With constraint, we suggest the browser for what kind of video stream it should look for. In the example, we set it to \u003Ccode\u003Euser\u003C\u002Fcode\u003E-facing camera – a.k.a. selfie camera, or the front one. Alternatively, we can specify we want to face \u003Ccode\u003Eenvironment\u003C\u002Fcode\u003E, which is what is observed by the back camera.\u003C\u002Fp\u003E\n\u003Cp\u003EThe constraint set this way only works as a suggestion, though – in case we run this code on a device equipped with back camera only, we&#39;d get the environment-facing stream anyway, as it&#39;s the only one available and it&#39;s still better to use whatever we have available instead of failing in most scenarios. But if our requirement is strict and we need to use the front camera or no camera, we can set an additional constraint using \u003Ccode\u003Eexact\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Econst stream = await navigator.mediaDevices.getUserMedia({\n    video: {\n        facingMode: {\n            exact: &#39;user&#39;\n        }\n    }\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003ENow, if the device only has an environment-facing camera, we&#39;d not get any stream and the Promise will be rejected with \u003Ccode\u003EOverconstrainedError\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Ch2 id=\"more-constraints\"\u003EMore constraints\u003C\u002Fh2\u003E\n\u003Cp\u003EFacing mode is not the only constraint specified by the Media Stream API. We may see the full list of constraint options using \u003Ccode\u003Enavigator.mediaDevices.getSupportedConstraints()\u003C\u002Fcode\u003E call. And this list might be quite impressive. This is what Chrome 80 on macOS lists as available:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E{\n    aspectRatio: true\n    autoGainControl: true\n    brightness: true\n    channelCount: true\n    colorTemperature: true\n    contrast: true\n    deviceId: true\n    echoCancellation: true\n    exposureCompensation: true\n    exposureMode: true\n    exposureTime: true\n    facingMode: true\n    focusDistance: true\n    focusMode: true\n    frameRate: true\n    groupId: true\n    height: true\n    iso: true\n    latency: true\n    noiseSuppression: true\n    pointsOfInterest: true\n    resizeMode: true\n    sampleRate: true\n    sampleSize: true\n    saturation: true\n    sharpness: true\n    torch: true\n    whiteBalanceMode: true\n    width: true\n    zoom: true\n    videoKind: true\n    pan: true\n    tilt: true\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EObviously, some of these constraint only make sense for audio and others for video streams.\u003C\u002Fp\u003E\n\u003Cp\u003EThe ones that might also be frequently used are these related with video resolution:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Econst stream = await navigator.mediaDevices.getUserMedia({\n    video: {\n        width: 1280,\n        height: 720\n    }\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003ENote that like with \u003Ccode\u003EfacingMode\u003C\u002Fcode\u003E, by default this is only a suggestion for what kind of stream we are looking for and the browser might as well provide the one with different size. We might again use \u003Ccode\u003Eexact\u003C\u002Fcode\u003E modifier to ask for exactly the size specified, but in case of resolution it&#39;s probably wiser to specify the minimum size we accept, using \u003Ccode\u003Emin\u003C\u002Fcode\u003E modifier:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Econst stream = await navigator.mediaDevices.getUserMedia({\n    video: {\n        width: {\n            min: 1280\n        },\n        height: {\n            min: 720\n        }\n    }\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EThe browser now will not provide a stream if it&#39;s not possible to find one with at least 1280x720 size.\u003C\u002Fp\u003E\n\u003Ch2 id=\"selecting-both-size-and-facing-mode\"\u003ESelecting both size and facing mode\u003C\u002Fh2\u003E\n\u003Cp\u003EAs the constraint is an object, nothing stops us from specifying more requirements, possibly with different modifiers. The browser will try to match as many as possible when providing the stream and in case we used \u003Ccode\u003Eexact\u003C\u002Fcode\u003E or \u003Ccode\u003Emin\u003C\u002Fcode\u003E modifiers that can&#39;t be satisfied, it will again reject the promise with \u003Ccode\u003EOverconstrainedError\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Econst stream = await navigator.mediaDevices.getUserMedia({\n    video: {\n        facingMode: &#39;environment&#39;,\n        width: {\n            min: 1280\n        },\n        height: {\n            min: 720\n        }\n    }\n})\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EIn this example, we&#39;re asking for the stream that should face the environment (back camera) when possible, but we also accept if only the front camera is available. For size we do not accept the sizes smaller than 1280 in width or 720 in height.\u003C\u002Fp\u003E\n",image:"\u002Farticleimgs\u002Fblack-camera-mounted-on-tripod.pexels.jpg",tags:["Media Capture API","Camera & Microphone"],description:"Most of the browsers nowadays, including mobile browsers, allow the applications to retrieve and use the data stream coming directly from the user's device camera. But it's very common for the devices nowadays to have more than one camera available and we might have a preference which of these cameras is better suited for our app's needs. Fortunately, the Media Stream API has us covered.",author:"\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fadambar.pl\"\u003EAdam Bar\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n",weight:1,source:a},otherArticles:[{title:"A Good Push Notification",url:"https:\u002F\u002Fpwafire.org\u002Fdeveloper\u002Fdocs\u002Fa-good-push-notification\u002F",image:"\u002Farticleimgs\u002Fletter-envelopes.pexels.jpg",tags:["Push Notifications"],description:"What makes a good Push Notifcation? Get tips to help you push value to your users and not users away.",source:"pwafire.org"},{title:"Handling Service Worker updates – how to keep the app updated and stay sane",slug:"handling-service-worker-updates",image:"\u002Farticleimgs\u002Ffloor-plan-on-table.pexels.jpg",tags:[b,"Offline Capabilities"],description:"Most of the Service Worker tutorials we can find on the Web focus on the initial development efforts needed to get the offline mode capabilities or performance gains for subsequent visits. But for production readiness, it is not enough, though. We need to have the update strategy in place not to cut off our users from actually getting the updates of our PWA.",weight:c,source:a},{title:"Progressive Web Apps – standard or buzzword?",slug:"progressive-web-apps-standard-or-buzzword",image:"\u002Farticleimgs\u002Fadult-books-business-coffee.pexels.jpg",tags:["PWA",b],description:"Progressive Web Apps (PWA) is modern way to build applications, including mobile ones, using purely web technologies and relying purely on the capabilities and strengths the Web platform. Historically, it was the lack of these capabilities on the Web that caused the boom of the mobile apps, using so-called \"native\" (platform-specific) development approaches.",weight:c,source:a}]}}("wwcd","Service Worker",2))]};if('serviceWorker' in navigator) window.addEventListener('load',function(){navigator.serviceWorker.register('/service-worker.js');});(function(){try{eval("async function x(){}");var main="/client/client.4b96b455.js"}catch(e){main="/client/legacy/client.a2a05ae8.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> 